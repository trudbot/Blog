---
date: '2024-06-21 17:01:17'
title: 红黑树
top: 0
outline: deep
tags:
- 二叉搜索树
- 红黑树
- 数据结构
- 平衡树
- AVL树
- B树
---

由于c++里已经有现成的红黑树(map)， 所以之前由于没有应用场景， 一直没有去了解红黑树。

现在为什么会去学习红黑树:

1. js的map很不好用
    1. 必须通过get、set函数操作值
    2. 没有默认值
2. js的map底层不是由红黑树实现， 导出的数据顺序甚至是插入顺序

本来想找一些第三方库， 但并没有找到比较好的, 于是打算自行填了红黑树这个坑, 实现工具自给自足。

---

前言: 红黑树是较为复杂的数据结构, 有比较多的背景知识, 所以本文将从科普平衡树的角度出发总结平衡树家族和红黑树由来。

## BST(二叉搜索树)

二叉搜索树在二叉树的基础上增加了如下性质的要求: 

1. 空树是一颗二叉搜索树
2. 二叉搜索树的左子树上任意结点的权值小于根结点
3. 二叉搜索树的右子树上任意结点的权值大于根结点
4. 二叉搜索树的左右子树均为二叉搜索树

>  从上面可以看出BST有个隐式的要求是不能出现两个权值相等的结点， 对于这种情况的处理一般是根据场景选择<后来者覆盖前者>或者<添加结点count值>

BST可以很好的解决可变序列的搜索问题。 试想一个数组里， 它将来可能需要删除某个元素， 也可能会添加进来一些元素， 你需要在这些情况发生的同时满足较快的搜索。

### BST的查找

将搜索值从根结点开始比较: 

* 当前结点权值与搜索值相同: 找到了
* 当前结点权值小于搜索值： 与左孩子进行比较
* 当前结点权值大于搜索值: 与右孩子进行比较
* 当前结点为空： 查找失败， 不存在

```typescript
searchNode(root: N | null, key: K): N | null {
    if (root === null) return null;
    const compareResult = this.compare(root.key, key);
    switch (compareResult) {
      case COMPARE_RESULT.EQUAL:
        return root;
      case COMPARE_RESULT.LESS:
        return this.searchNode(root.left, key);
      case COMPARE_RESULT.MORE:
        return this.searchNode(root.right, key);
    }
  }
```



BST的添加操作与此类似， 不再重复。

### BST的删除

首先在搜索树中查找到待删除值对应的结点。

* 待删除结点为叶子结点: 直接删除即可
* 待删除结点只有一个儿子: 删除结点后， 让唯一的儿子顶替其位置即可
* 待删除结点有两个儿子: 删除结点， 使用其【前驱】或【后继】顶替其位置

重点解释【前驱】和【后继】是什么， 以及为什么可以让它们顶替。

```mermaid
%%{ init: { 'flowchart': { 'curve': 'basis' } } }%%
flowchart TD
A((5)) --> B((3))
A --> C((7))
B --> D((2))
B --> E((4))
C --> F((6))
C --> G((8))

classDef commonNode fill: black,color: white,stroke:none
class A,B,C,D,E,F,G commonNode
```

以此树距离， 此树的中序遍历序列为

```
2, 3, 4, 5, 6, 7, 8
```

对于($5$)来说， ($4$)和($6$)分别是它的前驱、后继， 因为在中序序列中它们是($5$)的前后两个结点。

当($5$)被删除时， 使用 ($4$)或($6$)来顶替它的位置， 不会破坏搜索树的性质， 以($4$)举例。

**注**:  *NIL表示占位的空节点*

```mermaid
%%{ init: { 'flowchart': { 'curve': 'basis' } } }%%
flowchart TD
subgraph 删除5后
A((4)) --> B((3))
A --> C((7))
B --> D((2))
B --> NIL
C --> F((6))
C --> G((8))
end
subgraph 删除5前
a((5)) --> b((3))
a --> c((7))
b --> d((2))
b --> e((4))
c --> f((6))
c --> g((8))
end

classDef commonNode fill: black,color: white,stroke:none
class A,B,C,D,E,F,G,a,b,c,d,e,f,g,NIL commonNode
```

可以发现， 由于($4$)满足

1. 大于5左子树所有结点(除了4)
2. 小于5右子树所有结点

所以4天然可以取代5的位置；6同理。

N的前驱和后继的定义可以简化为:N左子树中权值最大的结点、N右子树中权值最小的结点。

### BST的最坏情况

BST进行搜索和删除的时间复杂度都与BST的高度h成正相关， 因为搜索操作最坏情况下需要从根一直比较到最深的叶子， 也就是h次比较。

即时间复杂度为$O(h)$， 而h在最好情况下为$logN$级别， 最坏情况下为$N$， 其中N为树的结点数量。

当BST为一条链时， 搜索和插入的时间复杂度为$O(N)$， 这是不能接受的。

而且通过一个有序（或大致有序）的插入顺序， 就能轻易使BST达到比较坏的情况。

```
1, 2, 3, 4, 5, 6, 7
```

```mermaid
%%{ init: { 'flowchart': { 'curve': 'basis' } } }%%
flowchart TD
A --> n1[NIL]
B --> n2[NIL]
C --> n3[NIL]
D --> n4[NIL]
E --> n5[NIL]
F --> n6[NIL]
A((1)) --> B((2))
B --> C((3))
C --> D((4))
D --> E((5))
E --> F((6))
F --> G((7))

classDef commonNode fill: black,color: white,stroke:none
class A,B,C,D,E,F,G,n1,n2,n3,n4,n5,n6 commonNode
```



## 平衡树

平衡树是改进的二叉搜索树, 不同的平衡树关于平衡的定义有所不同， 但总的来说是在追求: 各个叶子的深度(从根到各叶子结点的简单路径长度)趋于相近/平衡 (让树的高度尽量低， 不出现某分支的深度远远的超过其他分支的情况)。

### 自平衡树

自平衡树： 在插入、删除过后会自动调整树结构使其满足平衡定义的平衡树。

自平衡树相比于二叉搜索树而言， 多了插入和删除时的维护平衡操作。

平衡树 -> 插入或删除结点(通二叉搜索树) -> 平衡树失衡 -> 维护平衡



### 树的旋转

考虑如下BST: 

```mermaid
%%{ init: { 'flowchart': { 'curve': 'basis' } } }%%
flowchart TD
A((2)) --> B((1))
A --> C((4))
C --> F((3))
C --> D((5))
D --> n2[NIL]
D --> E((6))

classDef commonNode fill: black,color: white,stroke:none
class A,B,C,D,E,F,G,n1,n2 commonNode
```

右分支深度明显的大于左分支深度, 此时我们需要调整， 使这棵树更平衡、且不破坏BST性质。

此时便可以使用旋转, 旋转操作图示如下: 

![bst-rotate](https://trudbot-md-img.oss-cn-shanghai.aliyuncs.com/bst-rotate.svg)

![树旋转的过程演示](https://trudbot-md-img.oss-cn-shanghai.aliyuncs.com/Tree_rotation_animation_250x250.gif)

左旋、右旋的名字由来为根节点的移动方向， 具体的: 

左旋: 根结点移动到左子树上， 根结点的右儿子成为了新的根结点。

右旋: 根结点移动到右子树上,  根结点的右儿子成为了新的根结点。

从结果上看: 

```mermaid
%%{ init: { 'flowchart': { 'curve': 'basis' } } }%%
flowchart TD
subgraph after [左旋后]
a((4)) --> b((2))
b --> c((1))
a --> d((5))
b --> e((3))
d --> n1[NIL]
d --> f((6))
end
subgraph before [左旋前]
A((2)) --> B((1))
A --> C((4))
C --> F((3))
C --> D((5))
D --> n2[NIL]
D --> E((6))
end

classDef commonNode fill: black,color: white,stroke:none
class A,B,C,D,E,F,G,n1,n2,a,b,c,d,e,f commonNode
```



1. 旋转操作不会破坏BST性质(中序不变)
2. **左旋操作使原左子树深度+1， 原右儿子右子树深度-1。** 影响范围: (左+1、右右-1)
3. **右旋操作使原右子树深度+1， 原左儿子左子树深度-1。** 影响范围: (右+1、左左-1)

旋转操作是大多数平衡树维护平衡性质的操作， 时间复杂度为$O(1)$。

```typescript
/**
   * 左旋操作
   * @param node 左旋的子树根结点, 需要保证不为空且右子树不为空 
   * 
   *        g           p
   *       / \         / \
   *      u   p  -->  g   n
   *         / \     / \    
   *        m   n   u   m     
   */
rotateLeft(node: Node<K, V>) {
  const parent = node.parent;
  const direction = node.direction();
  const successor = node.right!;
  // 左旋核心操作, 根变为successor的左子树, successor变为根
  node.setRightChild(successor.left);
  successor.setLeftChild(node);

  // node的位置为successor取代, 需要更新node的父结点与successor的关系
  switch (direction) {
    case DIRECTION.LEFT:
      parent!.setLeftChild(successor);
      break;
    case DIRECTION.RIGHT:
      parent!.setRightChild(successor);
      break;
    case DIRECTION.ROOT:
      this.root = successor;
      break;
  }
}
```



### AVL树

AVL树的平衡定义:  对于树中任意一个结点, 其左子树深度和右子树深度的差值绝对值**不大于** $1$.

平衡因子：右子树高度 - 左子树高度

> AVL树名字的来源为它的两个发明者名字合并:  [Georgy Adelson-Velsky](https://en.wikipedia.org/wiki/Georgy_Adelson-Velsky) and [Evgenii Landis](https://en.wikipedia.org/wiki/Evgenii_Landis)

AVL树的性质保证了AVL树的高度为$logN$级别, 因此也被称为『高度平衡树』。

#### AVL树的维护操作

先说明几个事实

1. 插入/删除结点后， 可能导致包含该结点的所有子树树失衡
2. 由于是在AVL树上插入/删除了一个结点， 所以若一颗子树失衡, 其$|平衡因子|$只能为2

在AVL树插入/删除后, 我们将从插入/删除的结点的父结点开始向上(这样就能遍历到包含该结点的所有树)， 判断当前当前节点的平衡因子是否失衡， 若失衡则对当前结点进行维护。

维护操作可以分类讨论， 一些约定如下:

1. 所绘图中根结点（N）为失衡的结点(即h(L) - h(R) == 2 / -2)
2. L为N的左孩子、LL为L的左孩子(R、RR同理)
3. 结点名称后用括号注明高度
4. 『圆』为具体结点， 而梯形代指一颗树

一些事实如下:

1. 由于是自底向上进行维护， 当前讨论的是结点N, 那么L所在子树和R所在子树已经维护完成符合AVL树性质
2. 被插入/删除结点的爷爷结点开始， 才可能出现失衡

##### LL/RR型失衡

以LL型失衡举例, 这是一颗LL型失衡的树, 满足如下特征:

1. N的左子树比右子树高
1. L的左子树比右子树高 --> $H(LL) \ge H(LR)$

设$H(R) = h$， 则有

1. $H(L) = h + 2$
2. $H(LL) = h + 1$
3. $h \le H(LR) \le h + 1$

此时L和R的高度差可以看成是LL和R的高度差， 而右旋的效果为 (右+1、左左-1)满足此情况， 进行一次右旋即可。

```mermaid
%%{ init: { 'flowchart': { 'curve': 'basis' } } }%%
flowchart TD
subgraph gb [右旋后]
A --> D[/"LL (h + 1)"\]
A((L)) --> B(("N (h+1 / h+2)"))
B --> E[/"LR (h / h+1)"\]
B --> C[/"R (h)"\]
end
subgraph ga [失衡]
a(("N")) --> b(("L (h+2)"))
a --> c[/"R (h)"\]
b --> d[/"LL (h+1)"\]
b --> e[/"LR (h / h+1)"\]
end

classDef commonNode fill: black,color: white,stroke:none
class A,B,C,D,E,F,G,H,I,J,K,L,M,N,n1,n2,n3,n4,n5,n6,n7,n8,a,b,c,d,e,f,g,h,i,j,k,l,m,n commonNode
```

右旋后LL、LR、R的高度并不会变化， 此时我们可以计算出N的高度变为了$h + 1 \le H(N) \le h+2$, N子树和L子树都满足了AVL树性质， 修复完成!

##### LR/RL型失衡

同样只以LR型举例:

设$H(R) = h$, 则有

1. $H(L) = h + 2$;
2. $H(LL) = h$
3. $H(LR) = h + 1$
4. $h - 1 \le H(LRL) \le h$
5. $h - 1 \le H(LRR) \le h$

$LR/RL$型的失衡可以通过 L左旋 -> N右旋 来解决， 如下图

```mermaid
%%{ init: { 'flowchart': { 'curve': 'basis' } } }%%
flowchart TD
  subgraph gc [L左旋 + N 右旋后]
  k(("LR"))
  i(("L (h+1)"))
  h(("N (h+1)"))
  j[/"LL (h)"\]
  l[/"R (h)"\]
  m[/"LRL (h / h-1)"\]
  n[/"LRR (h / h-1)"\]
	
	k --> i
  k --> h
  i --> j
  i --> m
  h --> n
  h --> l
  end

  subgraph gb [L左旋后]
  A(("N"))
  B(("L (h + 1)"))
  D[/"LL (h)"\]
  E(("LR (h+2)"))
  C[/"R (h)"\]
  F[/"LRL (h / h-1)"\]
  G[/"LRR (h / h-1)"\]
  A --> E
  A --> C
  E --> B
  B --> D
  B --> F
  E --> G
  end

  subgraph ga [失衡]
  a(("N")) --> b(("L (h+2)"))
  a --> c[/"R (h)"\]
  b --> d[/"LL (h)"\]
  b --> e(("LR (h+1)"))
  e --> f[/"LRL (h / h-1)"\]
  e --> g[/"LRR (h / h-1)"\]
  end


classDef commonNode fill: black,color: white,stroke:none
class A,B,C,D,E,F,G,H,I,J,K,L,M,N,n1,n2,n3,n4,n5,n6,n7,n8,a,b,c,d,e,f,g,h,i,j,k,l,m,n commonNode
```

从结果上看, 操作完成后$H(L) = h + 1, H(N) = h + 1$， 符合AVL树性质。

> Todo: 是怎么想到用先后两次不同的旋转来修复性质的?是否蕴含着数学原理



### B树

![img](https://trudbot-md-img.oss-cn-shanghai.aliyuncs.com/400px-B-tree.svg.png)

B树是一种自平衡多叉树。

一颗 $m$阶B树满足如下性质:

1. 每个结点最多有$m$个子结点
2. 每个非叶子结点(除了根)至少有$\lceil m / 2 \rceil$
3. 如果根节点不是叶子节点，那么它至少有两个子节点。
4. 若一个结点有有k个子结点， 那么该结点有k-1个键， 反之亦然； 
5. 每个结点的键值升序排列， 且n的第k个子节点的所有键值满足小于n的第k个键值、大于n的第k-1个键值
6. 所有的叶子节点都在同一层。



### 红黑树

红黑树是满足如下性质的二叉搜索树:

1. 每一个结点要么是红色， 要么是黑色
2. 红色结点的孩子必须为黑色
3. 对于红黑树中任意一个结点， 它到NIL(null)结点的每一条简单路径必须包含相同数量的黑色结点

除此之外， 还有两条被广泛使用的红黑树的性质 

4. 根结点是黑色
5. NIL(null)结点被认为是黑色

这两条性质对于红黑树来说并不是必须的， 但能便利对红黑树的算法归纳， 我们姑且也认为这是红黑树必须满足的性质。



红黑树最初是从B树中推导出来的,  事实上红黑树可以等价的看做四阶B树。

#### 红黑树与4阶B树

以下引用自: [红黑树 | Jason‘s Blog (jasonxqh.github.io)](https://jasonxqh.github.io/2020/11/03/红黑树/)

> 红黑树和4阶B树之间存在等价关系。如哦从红黑树的树根开始，自顶向下逐层检查，如果遇到红结点，则将该节点压缩到父节点一侧；如果遇到黑节点，则保留。因为**红结点对黑高没有贡献**，而黑结点对黑高有贡献。
>
> 红黑树与4阶B树的4种等价方式：
>
> 1） 两个黑孩子(黑黑)，如图所示：
>
> ![img](https://trudbot-md-img.oss-cn-shanghai.aliyuncs.com/2.png)
>
> 2）左黑右红(黑红)，如图所示：
>
> ![img](https://trudbot-md-img.oss-cn-shanghai.aliyuncs.com/3.png)
>
> \3) 左红右黑(红黑) ，如图所示：
>
> ![img](https://trudbot-md-img.oss-cn-shanghai.aliyuncs.com/4.png)
>
> 4）两个红孩子(红红)，如图所示
>
> ![img](https://trudbot-md-img.oss-cn-shanghai.aliyuncs.com/5.png)
>
> 从红黑树与4阶B树的等价关系可以看出，4阶B树中的结点中必然含有一个黑节点。而且不会出现红色的父亲。每一个结点最多包含三个关键字：如果包含2个红关键字，则黑关键字必然在中间位置。
>
> 我们可以尝试将这一棵红黑树进行压缩。
>
> ![img](https://trudbot-md-img.oss-cn-shanghai.aliyuncs.com/1.png)
>
> 最后可以得到这样一棵4阶的B树
>
> ![img](https://trudbot-md-img.oss-cn-shanghai.aliyuncs.com/1.jpg)
>
> 那么既然红黑树和4阶B树是可以互相转化的，那么为什么还要用红黑树呢？这是因为红黑树和B树处理的方向不同。B树主要用于内外存的访问，旋转不是很容易，但是红黑树的旋转调平衡比较方便



#### 插入

红黑树的插入， 首先将插入结点按照BST的规则插入树中， 然后判断是否会导致失衡， 根据其情况使用不同策略进行修正。

一些约定:

1. N为插入的结点
2. P为`parent`父亲结点
3. G为`grandparent`爷爷结点
4. U为`uncle`叔叔结点
5. 圆形结点为具体的节点； 梯形结点代表一颗无需透露细节的子树
6. 结点名称后如有括号， 则表示该节点到叶子结点的黑色数量

一些事实:

1. 插入的结点必然为红色结点。 因为被插入的树已经满足红黑树性质， 此时如果插入一个黑色结点， 那么必然会让某条路径的黑色数量+1， 造成失衡(除空树情况)
2. 空树情况下， 将插入结点更改为黑色即可
3. 插入结点的父亲为黑色时， 不会破坏红黑树性质。 

排除以上情况时， 必然满足:

1. 插入结点有父结点且父结点为红色
2.  插入结点有爷爷且爷爷为黑色

接下来我们将以`uncle`为 红/黑 时分类讨论剩下的失衡情况。

##### uncle为红色时

此时我们将G染红， P和U染黑，此时G子树已经修正了性质， 但G变红可能导致更上层的失衡， 因此我们将G当成刚插入的结点， 递归地维护。 

```mermaid
%%{ init: { 'flowchart': { 'curve': 'basis' } } }%%
flowchart TD
subgraph 换色后
g((G))
p((P))
u((U))
n((N))
pr[/ \]
nl[/ \]
nr[/ \]
ul[/ \]
ur[/ \]

g --> p
g --> u
p --> n
p --> pr
n --> nl
n --> nr
u --> ul
u --> ur
end
subgraph 失衡状态
G((G))
P((P))
U((U))
N((N))
PR[/ \]
NL[/ \]
NR[/ \]
UL[/ \]
UR[/ \]

G --> P
G --> U
P --> N
P --> PR
N --> NL
N --> NR
U --> UL
U --> UR
end

classDef tree fill: white, color: black, stroke: black
classDef blackNode fill: black,color: white,stroke:none
classDef redNode fill: red,color: white,stroke: none
class G,p,u blackNode
class P,N,U,g,n redNode
class PR,NL,NR,UL,UR,pr,nl,nr,ul,ur tree
```

```typescript
if (uncle && uncle.isRed()) {
  uncle.setBlack();
  parent.setBlack();
  gparent.setRed();
  this.maintainAfterInsert(gparent);
  return;
}
```



##### uncle为黑色时: LL/RR型失衡

以`LL`型失衡举例(P为G的左儿子， N为P的左儿子)

```mermaid
%%{ init: { 'flowchart': { 'curve': 'basis' } } }%%
flowchart TD
G((G))
P((P))
U((U))
N((N))
PR[/ \]
NL[/ \]
NR[/ \]
UL[/ \]
UR[/ \]

G --> P
G --> U
P --> N
P --> PR
N --> NL
N --> NR
U --> UL
U --> UR
classDef tree fill: white, color: black, stroke: black
classDef blackNode fill: black,color: white,stroke:none
classDef redNode fill: red,color: white,stroke: none
class G,U blackNode
class P,N redNode
class PR,NL,NR,UL,UR tree
```

我们从4阶B树的角度上看(B树的图非常重要非常好):

![img](https://trudbot-md-img.oss-cn-shanghai.aliyuncs.com/6.png)

在不破坏搜索树性质的情况下， 如上B树只需交换p、g颜色即可。

> 回收前文的一些疑问:
>
> **为什么要分uncle为红还是黑？**
>
> 由上图可以发现， 当uncle为红时， x-p-g这一层还要加一个u变成 x-p-g-u
>
> ![image-20240624221100810](https://trudbot-md-img.oss-cn-shanghai.aliyuncs.com/image-20240624221100810.png)
>
> 4阶B树的结点键值数超过了3， 此时发生上溢， 需要进行分裂操作， 如上图。
>
> g变为红色后, g的上层可能失衡， 因此需要递归向上解决。
>
> **叶子结点为什么要认为是黑色?**
>
> 在解决红黑树的失衡过程中， 经常遇到需要根据某个结点的颜色分类讨论的情况, 但我们发现，讨论结点的颜色其实只是在区分  红色(B树形式中会压缩到父结点) / 非红色(不会在父结点中) 两种情况。
>
> 所以没有必要每次都加一条: 如果为空， 如何如何。



而由于4阶B树形式中黑色为根结点， 换成二叉树操作需要分为两步:

1. 基于g进行右旋
2. 将p染黑， g染红

```mermaid
%%{ init: { 'flowchart': { 'curve': 'basis' } } }%%
flowchart TD
subgraph 右旋 + 换色后
p((P))
u((U))
n((N))
g((G))
pr[/ \]
nl[/ \]
nr[/ \]
ul[/ \]
ur[/ \]

p --> n
n --> nl
n --> nr
p --> g
g --> pr
g --> u
u --> ul
u --> ur
end
subgraph 失衡状态
G((G))
P((P))
U((U))
N((N))
PR[/ \]
NL[/ \]
NR[/ \]
UL[/ \]
UR[/ \]

G --> P
G --> U
P --> N
P --> PR
N --> NL
N --> NR
U --> UL
U --> UR
end

classDef tree fill: white, color: black, stroke: black
classDef blackNode fill: black,color: white,stroke:none
classDef redNode fill: red,color: white,stroke: none
class G,p,u blackNode
class P,N,U,g,n redNode
class PR,NL,NR,UL,UR,pr,nl,nr,ul,ur tree
```

```typescript
if (parent.direction() === node.direction()) {

  if (node.direction() === DIRECTION.LEFT) {
    // LL型失衡
    this.rotateRight(gparent);
  } else {
    // RR型失衡
    this.rotateLeft(gparent);
  }

  parent.setBlack();
  gparent.setRed();
}
```

##### uncle为黑色时: LR/RL型失衡

以LR型失衡举例(P为G的左儿子， N为P的右儿子):

```mermaid
%%{ init: { 'flowchart': { 'curve': 'basis' } } }%%
flowchart TD
G((G))
P((P))
U((U))
PL[/ \]
N((N))
NL[/ \]
NR[/ \]
UL[/ \]
UR[/ \]

G --> P
G --> U
P --> PL
P --> N
N --> NL
N --> NR
U --> UL
U --> UR
classDef tree fill: white, color: black, stroke: black
classDef blackNode fill: black,color: white,stroke:none
classDef redNode fill: red,color: white,stroke: none
class G,U blackNode
class P,N redNode
class PL,NL,NR,UL,UR tree
```

同样转化为4阶B树形式:



![img](https://trudbot-md-img.oss-cn-shanghai.aliyuncs.com/8.png)



同样是出现了连续的红色， 同样把中间染黑， 但LR要进行的操作要多一点： 

1. 基于P进行左旋

```mermaid
%%{ init: { 'flowchart': { 'curve': 'basis' } } }%%
flowchart TD
subgraph P左旋后
g((G))
p((P))
n((N))
u((U))
pl[/ PL \]
nl[/ NL \]
nr[/ NR \]
ul[/ UL \]
ur[/ UR \]

g --> n
g --> u
n --> p
n --> nr
p --> pl
p --> nl
u --> ul
u --> ur
end
subgraph 失衡状态
G((G))
P((P))
U((U))
PL[/ PL \]
N((N))
NL[/ NL \]
NR[/ NR \]
UL[/ UL \]
UR[/ UR \]

G --> P
G --> U
P --> PL
P --> N
N --> NL
N --> NR
U --> UL
U --> UR
end
classDef tree fill: white, color: black, stroke: black
classDef blackNode fill: black,color: white,stroke:none
classDef redNode fill: red,color: white,stroke: none
class G,U,g,u blackNode
class P,N,p,n redNode
class PL,NL,NR,UL,UR,pl,nl,nr,ul,ur tree
```

2. 基于G右旋
3. 将N染黑, 将G染红

```mermaid
%%{ init: { 'flowchart': { 'curve': 'basis' } } }%%
flowchart TD

subgraph "P左旋 + G右旋 + N、G换色后"
P((P))
G((G))
N((N))
U((U))
PL[/ PL \]
NL[/ NL \]
NR[/ NR \]
UL[/ UL \]
UR[/ UR \]

N --> P
P --> PL
P --> NL
N --> G --> NR
G --> U
U --> UL
U --> UR
end
subgraph P左旋后
g((G))
p((P))
n((N))
u((U))
pl[/ PL \]
nl[/ NL \]
nr[/ NR \]
ul[/ UL \]
ur[/ UR \]

g --> n
g --> u
n --> p
n --> nr
p --> pl
p --> nl
u --> ul
u --> ur
end

classDef tree fill: white, color: black, stroke: black
classDef blackNode fill: black,color: white,stroke:none
classDef redNode fill: red,color: white,stroke: none
class G,U,g,u,N blackNode
class P,p,n,G redNode
class PL,NL,NR,UL,UR,pl,nl,nr,ul,ur tree
```

#### 删除

在删除过程中， 我们现对欲删除的键值进行搜索， 在搜索到的节点为N的情况下:

> 1. 若N有两个孩子， 将其前驱(或后继)结点的键与值与N替换(不替换颜色)，此时要删除的结点改为了前驱(或后继)结点

经过了`(1)`， 我们确认了要删除的结点究竟是哪个, 接下来以N代指要删除的结点, 此时我们继续分情况讨论: 

> 2. 若N为树中唯一的结点， 直接删除即可

> 3. 若N有左/右孩子, 删除N后用它的左/右孩子代替N的位置(由于前驱或后继的性质, N不可能有两个孩子)

`(2)`、`(3)策略保证了删除后BST的性质正确,  接下来从红黑树性质上考虑删除后如何修正: 

> 4. 若N为红色, 不会破坏红黑树性质， 无需维护

当删除一个红色结点时, 并不会改变路径中黑色结点的数量； 同时顶替它位置的左/右孩子 和 父亲(如果存在) 必然是黑色结点, 不会破坏*红色结点的孩子必须为黑色*的性质

> 5. 若N有孩子
>     1. N的孩子必然为红色， 否则N子树不满足红黑树性质

```mermaid
%%{ init: { 'flowchart': { 'curve': 'basis' } } }%%
flowchart TD
subgraph 删除N后
p((P))
pl[/"PL(k)"\]
r(("R(k-1)"))
rl[NIL]
rr[NIL]
p --> pl
p --> r
r --> rl
r --> rr
end
subgraph 删除N前
P((P))
PL[/"PL(k)"\]
N(("N(k)"))
R(("R(k-1)"))
NR[NIL]
RL[NIL]
RR[NIL]

P --> PL
P --> N
N --> R
N --> NR
R --> RL
R --> RR
end

classDef tree fill: white, color: black, stroke: black
classDef blackNode fill: black,color: white,stroke:none
classDef redNode fill: red,color: white,stroke: none
class G,U,N,NR,rl,rr,RL,RR blackNode
class R,r,p,P redNode
class PL,NL,UL,UR,pl tree
```

删除N后, N所在路径的黑色数量减少， 必然导致不同路径的黑色数量不同； 且当P为红色时， 又破坏了红结点孩子必须为黑结点的性质。

此时我们将R染黑， 就同时解决了两条性质的失衡问题:

```mermaid
%%{ init: { 'flowchart': { 'curve': 'basis' } } }%%
flowchart TD
subgraph R染黑后
p((P))
pl[/"PL(k)"\]
r(("R(k)"))
rl[NIL]
rr[NIL]
p --> pl
p --> r
r --> rl
r --> rr
end
subgraph R染黑前
P((P))
PL[/"PL(k)"\]
R(("R(k-1)"))
RL[NIL]
RR[NIL]

P --> PL
P --> R
R --> RL
R --> RR
end

classDef tree fill: white, color: black, stroke: black
classDef blackNode fill: black,color: white,stroke:none
classDef redNode fill: red,color: white,stroke: none
class G,U,N,NR,r,rl,rr,RL,RR blackNode
class R,p,P redNode
class PL,NL,UL,UR,pl tree
```

##### 删除操作修正原理

让我们思考删除一个黑色结点N造成的后果, 本质上就是P(N的父亲)的两颗子树的黑色深度不再相等(**N所在子树黑色深度减一**)， 此时解决方法无非:

1. 在保证P树黑色深度不变的情况下， 弥补N所在子树减少的黑色深度, 此时必然需要有一个红色结点被染成了黑色结点
    * 被染黑的红色结点哪里来? 
        * 在N所在子树上， 代替N位置
        * 在S子树上,  需要调整结构让N子树多一个黑色结点
        * P染黑, S染红
    
1. (1)无法实现的情况下, 维护两颗子树黑色深度相同且将P树整体的黑色深度减一， 此时相当于"P被删了"， 向上递归维护。

我想表达的意思是, 删除黑色叶子结点后的维护操作, 应该将其看作一个整体、一颗子树的黑色深度减一， 但它内部依然符合红黑树性质， 这样去理解， 进而复用到更广的情况。

我们重回`(5)`的情况, 5的情况本质是N子树的黑色数量减了1， 所以用了一个本身在N子树上的红色结点染黑进行替代

而在N子树内部解决不了问题， 就将问题抛给了上层。 

**P为红色, S和S两个孩子均为黑色 **

```mermaid
%%{ init: { 'flowchart': { 'curve': 'basis' } } }%%
flowchart TD
subgraph 维护后
p((P))
n((N))
s((S))
sl((SL))
sr((SR))
p --> n
p --> s
s --> sl
s --> sr
end
subgraph 失衡
P((P))
N((N))
S((S))
SL((SL))
SR((SR))

P --> N
P --> S
S --> SL
S --> SR
end
classDef tree fill: white, color: black, stroke: black
classDef blackNode fill: black,color: white,stroke:none
classDef redNode fill: red,color: white,stroke: none
class P,s redNode;
class S,N,SL,SR,p,sl,sr,n blackNode;
class PL,NL,UL,UR,pl tree
```

此时将P染黑、S染红, 显然符合:

1. P子树和S路径黑色深度不变
2. s子树红黑树性质未遭到破坏
3. N路径黑色深度+1

即成功的为N擦了屁股。

```typescript
sibling.setRed();
parent.setBlack();
```



**P为黑色， S和S两个孩子均为黑色**

```mermaid
%%{ init: { 'flowchart': { 'curve': 'basis' } } }%%
flowchart TD
subgraph 维护后
P((P))
N((N))
S((S))
SL((SL))
SR((SR))

P --> N
P --> S
S --> SL
S --> SR
end
subgraph 失衡
p((P))
n((N))
s((S))
sl((SL))
sr((SR))
p --> n
p --> s
s --> sl
s --> sr
end
classDef tree fill: white, color: black, stroke: black
classDef blackNode fill: black,color: white,stroke:none
classDef redNode fill: red,color: white,stroke: none
class S redNode;
class S,N,SL,SR,p,sl,sr,n,s,P blackNode;
class PL,NL,UL,UR,pl tree
```



我们将S染红， P的两条路径下的黑色深度都减一, 将问题抛给上层。

```typescript
sibling.setRed();
this.maintain(parent.parent);
```

**P任意, S为黑色， N远侄为红色, 近侄任意**

> 当N为P左儿子时， S的左儿子为近侄， 右儿子为远侄； 反之同理。

```mermaid
%%{ init: { 'flowchart': { 'curve': 'basis' } } }%%
flowchart TD
subgraph 维护后
P((P))
N((N))
S((S))
SL((SL))
SR((SR))

S --> P
P --> N
S --> SR
P --> SL
end
subgraph 失衡
p((P))
n((N))
s((S))
sl((SL))
sr((SR))
p --> n
p --> s
s --> sl
s --> sr
end
classDef tree fill: white, color: black, stroke: black
classDef blackNode fill: black,color: white,stroke:none
classDef redNode fill: red,color: white,stroke: none
class sr redNode;
class N,SR,n,s,P blackNode;
class PL,NL,UL,UR,pl,sl,p,SL,S tree
```

1. P向N方向旋转
2. S和P交换颜色, 远侄染黑

此时各方面都满足性质

**P任意,  N近侄为红色， 远侄为黑色**

```mermaid
%%{ init: { 'flowchart': { 'curve': 'basis' } } }%%
flowchart TD
subgraph 维护后
p((P))
n((N))
sll[/ \]
slr[/ \]
s((S))
sl((SL))
sr((SR))
p --> n
p --> sl
sl --> sll
sl --> s
s --> slr
s --> sr

end
subgraph 失衡
P((P))
N((N))
S((S))
SL((SL))
SR((SR))

P --> N
P --> S
S --> SL
S --> SR

end
classDef tree fill: white, color: black, stroke: black
classDef blackNode fill: black,color: white,stroke:none
classDef redNode fill: red,color: white,stroke: none
class SL,s redNode;
class N,SR,n,S,sr,sl blackNode;
class PL,NL,UL,UR,pl,p,P,sll,slr tree
```

1. 将S向远侄方向右旋
2. 将近侄染黑， S染红

此时情况变为了**P任意, S为黑色， N远侄为红色, 近侄任意**, 用同样方法解决即可。

以上四种情况， 我们枚举完了S为黑色的所有情况, 接下来考虑S为红色的情况

**S为红色**

此时P和S的孩子只能为黑色, 且S必然有真实孩子

1. P向N方向旋转
2. P染红, S染黑

 ```mermaid
 %%{ init: { 'flowchart': { 'curve': 'basis' } } }%%
 flowchart TD
 subgraph 维护后
 s((S))
 p((P))
 sr((SR))
 n((N))
 sl((SL))
 
 s --> p
 p --> n
 p --> sl
 s --> sr
 end
 subgraph 失衡
 P((P))
 N((N))
 S((S))
 SL((SL))
 SR((SR))
 
 P --> N
 P --> S
 S --> SL
 S --> SR
 end
 classDef tree fill: white, color: black, stroke: black
 classDef blackNode fill: black,color: white,stroke:none
 classDef redNode fill: red,color: white,stroke: none
 class S,p redNode;
 class N,P,SL,SR,s,n,sl,sr blackNode;
 class PL,NL,UL,UR,pl tree
 ```

此时可以发现整棵树相比之前的变化就是N下移， sibling变为了SL， 其他部分并未失衡。

继续在新的P子树上继续维护即可。

```typescript
if (sibling.isRed()) {
  if (direction === DIRECTION.LEFT) {
    this.rotateLeft(parent);
  } else {
    this.rotateRight(parent);
  }
  sibling.setBlack();
  parent.setRed();
  this.afterErase(parent);
}
```



### 红黑树和AVL树的比较

1. 如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度。
2. AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。

## 参考

[rbtree.c-linux源码](https://elixir.bootlin.com/linux/latest/source/lib/rbtree.c)

[红黑树 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/ds/rbtree/#case-4)

[红黑树（图解+秒懂+史上最全） - 疯狂创客圈 - 博客园 (cnblogs.com)](https://www.cnblogs.com/crazymakercircle/p/16320430.html#autoid-h3-8-8-0)

[红黑树 | Jason‘s Blog (jasonxqh.github.io)](https://jasonxqh.github.io/2020/11/03/红黑树/)

[数据结构-B树与红黑树 - Shuzang's Blog](http://shuzang.top/2020/data-structure-b-tree-and-red-black-tree/#24-删除)

[Red–black tree - Wikipedia](https://en.wikipedia.org/wiki/Red–black_tree)

[The-Art-Of-Programming-By-July-2nd/ebook/zh/03.01.md at master · julycoding/The-Art-Of-Programming-By-July-2nd (github.com)](https://github.com/julycoding/The-Art-Of-Programming-By-July-2nd/blob/master/ebook/zh/03.01.md)

[平衡树 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/平衡树)

Weiss M A. 数据结构与算法分析 C语言描述（第2版）. 冯舜玺 译. 机械工业出版社, 2004.

## 红黑树参考代码

rb-node.ts:

```typescript
type COLOR = "RED" | "BLACK";
export type NIL = null;
export enum DIRECTION {
  LEFT = 'left',
  RIGHT = 'right',
  ROOT = 'root'
}

export class TreeNode<K, V, N extends TreeNode<K, V, N>> {
  key: K;
  value: V;
  left: N | NIL = null;
  right: N | NIL = null;
  parent: N | NIL = null;

  constructor(key: K, value: V) {
    this.key = key;
    this.value = value;
  }

  isRoot() {
    return this.parent === null;
  }

  isLeaf() {
    return this.left === null && this.right === null;
  }
  
  setLeftChild(child: N | null) {
    this.left = child;
    child && (child.parent = this as unknown as N);
    return this;
  }
  
  setRightChild(child: N | null) {
    this.right = child;
    child && (child.parent = this as unknown as N);
    return this;
  }

  direction() {
    if (this.parent === null) return DIRECTION.ROOT;
    if (this.parent.left === this as unknown as N) return DIRECTION.LEFT;
    else return DIRECTION.RIGHT;
  }

  sibling() {
    const direct = this.direction();
    if (direct === DIRECTION.LEFT) {
      return this.parent?.right;
    } else {
      return this.parent?.left;
    }
  }

  hasSibling() {
    return !this.isRoot() && this.sibling();
  }

  uncle() {
    return this.parent?.sibling() || null;
  }

  hasUncle() {
    return this.parent?.hasSibling();
  }
}

const tree = new TreeNode('1', 2);

export class RB_Node<K, V> extends TreeNode<K, V, RB_Node<K, V>> {
  color: COLOR = "RED";

  constructor(key: K, value: V) {
    super(key, value);
  }

  isRed() {
    return this.color === "RED";
  }
  
  isBlack() {
    return this.color === "BLACK"
  }

  setBlack() {
    this.color = "BLACK";
    return this;
  }
  
  setRed() {
    this.color = "RED";
    return this;
  }

  static isRed(node: RB_Node<any, any> | null) {
    return node && node.isRed();
  }

  static isBlack(node: RB_Node<any, any> | null) {
    return !node || node.isBlack();
  }
}

```



Rbtree.ts:

```typescript
import { RB_Node, NIL, DIRECTION, TreeNode } from './rb-node.js';
const isDev = true;

enum COMPARE_RESULT {
  EQUAL = 0,
  LESS = -1,
  MORE = 1
}

type Compare<K> = (a: K, b: K) => 
  COMPARE_RESULT.MORE |  // a > b
  COMPARE_RESULT.EQUAL |  // a === b
  COMPARE_RESULT.LESS;  // a < b

/**
 * newChild替换oldChild的位置, par
 * @param parent oldChild的父结点
 * @param oldChild 原结点
 * @param newChild 新结点
 * @param setRoot 将新结点设置为根结点
 */
function changeChild<N extends TreeNode<any, any, N>>(parent: N, oldChild: N, newChild: N | null, setRoot?: (node: N | null) => void) {
  switch (oldChild.direction()) {
    case DIRECTION.LEFT:
      parent.setLeftChild(newChild);
      break;
    case DIRECTION.RIGHT:
      parent.setRightChild(newChild);
      break;
    case DIRECTION.ROOT:
      setRoot && setRoot(newChild);
      break;
  }
}

export class BS_Tree<K, V, N extends TreeNode<K, V, N>> {
  protected root: N | NIL = null;
  protected compare: Compare<K>;

  constructor(compare?: Compare<K>) {
    this.compare = compare || ((a, b) => {
      return a === b ? 0 : (a > b ? 1 : -1);
    });
  }

  setRoot(node: N | null) {
    this.root = node;
    node && (node.parent = null);
  }

  Traversal(root: N | null, callback: (node: N) => void) {
    if (root === null) return;
    callback(root);
    this.Traversal(root.right, callback);
    this.Traversal(root.left, callback);
  }

  /**
   * 递归地将结点插入二叉搜索树
   * @param root 被插入的树的根
   * @param node 插入的结点
   * @param replace 结点key相同时是否直接替换
   */
  insertNode(root: N | null, node: N, replace: boolean = true) {
    if (root === null) {
      this.setRoot(node);
      return node;
    }
    const compareResult = this.compare(root.key, node.key);
    if (compareResult === COMPARE_RESULT.EQUAL) {
      replace && (root.value = node.value);
    } else if (compareResult === COMPARE_RESULT.MORE) {
      if (root.left !== null) {
        this.insertNode(root.left, node, replace);
      } else {
        root.setLeftChild(node);
      }
    } else {
      if (root.right !== null) {
        this.insertNode(root.right, node, replace);
      } else {
        root.setRightChild(node);
      }
    }
  }

  

  /**
   * 根据键值在树中查找结点
   * @param root 子树根
   * @param key 欲删除的键值
   * @returns 查找结果 Node | null
   */
  searchNode(root: N | null, key: K): N | null {
    if (root === null) return null;
    const compareResult = this.compare(root.key, key);
    switch (compareResult) {
      case COMPARE_RESULT.EQUAL:
        return root;
      case COMPARE_RESULT.LESS:
        return this.searchNode(root.right, key);
      case COMPARE_RESULT.MORE:
        return this.searchNode(root.left, key);
    }
  }

  /**
   * 根据键值在树中删除一个结点, 并返回删除的结点
   * 
   */
  eraseNode(root: N | null, key: K, copyData?: (target: N, source: N) => void): N | null {
    const node = this.searchNode(root, key);

    if (node === null) return null;

    if (node.left && node.right) {
      // node有两个孩子, 使用前驱结点替换node
      const leftMax = this.leftMaxNode(node)!;
      console.assert(leftMax !== null, "leftMax should not be null when node has two children");
      // 前驱结点与node交换数据
      if (copyData) {
        copyData(node, leftMax!);
      } else {
        node.key = leftMax!.key;
        node.value = leftMax!.value;
      }

      // 删除原前驱结点, 前驱结点必然没有右儿子
      const leftMaxParent = leftMax.parent!;
      console.assert(leftMaxParent !== null, "leftMax should have parent");
      console.assert(leftMax.right === null, "leftMax should not have right child");
      changeChild<N>(leftMaxParent, leftMax, leftMax.left, (node) => {
        this.setRoot(node);
      });
      return leftMax;
    } else if (node.left) {
      // 左结点顶替node位置
      const parent = node.parent;
      changeChild(parent!, node, node.left, (node) => {
        this.setRoot(node);
      });
    } else if (node.right) {
      // 右结点顶替node位置
      const parent = node.parent;
      changeChild(parent!, node, node.right, (node) => {
        this.setRoot(node);
      });
    } else {
      // node为叶子结点, 直接删除
      changeChild<N>(node.parent!, node, null, (node) => {
        this.setRoot
      });
    }
    return node;
  }

  /**
   * 左子树中的最大key结点
   * @param root 子树根
   * @returns 
   */
  leftMaxNode(root: N | null): N | null {
    if (root === null || root.left === null) return null;
    let node = root.left!;
    while (node.right !== null) {
      node = node.right;
    }
    return node;
  }
}

/**
 * 红黑树
 * 参考linux红黑树源码: https://elixir.bootlin.com/linux/latest/source/lib/rbtree.c
 * 遵循性质如下:
 * 1. 每个结点要么是红色, 要么是黑色
 * 2. root是黑色
 * 3. 每个叶结点(NIL)是黑色
 * 4. 红色结点的子结点都是黑色
 * 5. 从任意结点到其每个叶结点的路径上包含相同数量的黑色结点
 * 
 */
export class RB_Tree<K, V> extends BS_Tree<K, V, RB_Node<K, V>> {

  constructor(compare?: Compare<K>) {
    super(compare);
  }

  get(key: K) {
    const node = this.searchNode(this.root, key);
    return node ? node.value : null;
  }

  insert(key: K, value: V) {
    const node = new RB_Node(key, value);
    this.insertNode(this.root, node);
    this.afterInsert(node);
  }

  /**
   * 左旋操作
   * @param node 左旋的子树根结点, 需要保证不为空且右子树不为空 
   * 
   *        g           p
   *       / \         / \
   *      u   p  -->  g   n
   *         / \     / \    
   *        m   n   u   m     
   */
  rotateLeft(node: RB_Node<K, V>) {
    console.assert(node !== null && node.right !== null, "node and node->left should not be null in rotateLeft");
    const parent = node.parent;
    const direction = node.direction();
    const successor = node.right!;
    // 左旋核心操作, 根变为successor的左子树, successor变为根
    node.setRightChild(successor.left);
    successor.setLeftChild(node);

    // node的位置为successor取代, 需要更新node的父结点与successor的关系
    switch (direction) {
      case DIRECTION.LEFT:
        console.assert(parent !== null, "parent should not be null when direction is left");
        parent!.setLeftChild(successor);
        break;
      case DIRECTION.RIGHT:
        console.assert(parent !== null, "parent should not be null when direction is right");
        parent!.setRightChild(successor);
        break;
      case DIRECTION.ROOT:
        this.setRoot(successor);
        break;
    }
  }

  /**
   * 右旋操作
   * @param node 右旋的子树根结点, 需要保证不为空且左子树不为空
   * 
   *        g           p
   *       / \         / \
   *      p   u  -->  n   g
   *     /  \            / \
   *    n    m          m   u
   */
  rotateRight(node: RB_Node<K, V>) {
    console.assert(node !== null && node.left !== null, "node and node->left should not be null in rotateRight");

    const parent = node.parent;
    const direction = node.direction();
    const successor = node.left!;

    node.setLeftChild(successor.right);
    successor.setRightChild(node);

    switch (direction) {
      case DIRECTION.LEFT:
        console.assert(parent !== null, "parent should not be null when direction is left");
        parent!.setLeftChild(successor);
        break;
      case DIRECTION.RIGHT:
        console.assert(parent !== null, "parent should not be null when direction is right");
        parent!.setRightChild(successor);
        break;
      case DIRECTION.ROOT:
        this.setRoot(successor);
        break;
    }
  }

  /**
   * 维护插入结点后的树使其满足红黑树性质
   * @node 刚被插入的结点
   */
  afterInsert(node: RB_Node<K, V>) {
    // 插入结点的父结点, 以父亲代称
    const parent = node.parent;
    /**
     * case1: 插入的结点为根节点
     * 将其染黑即可
     */
    if (parent === null) {
      node.setBlack();
      isDev && console.log('case1');
      return;
    }

    /**
     * case2: 插入结点的父结点为黑色
     * 不会破坏红黑树性质, 直接结束
     */
    if (parent.isBlack()) {
      isDev && console.log('case2');
      return;
    }

    // 插入结点的爷爷结点, 以爷爷代称
    // 爷爷必然存在, 因为如果父亲是根节点, 必然是黑色, 那么不会进入这一步
    const gparent = parent.parent!;
    console.assert(gparent !== null, "gparent should not be null in pass case2");

    // 叔叔
    const uncle = gparent && node.uncle();

    /**
     * case3: 父亲和叔叔都为红色
     *
     *       G            g
     *      / \          / \
     *     p   u  -->   P   U
     *    /            /
     *   n            n
     * step1: 将爷爷变为红色, 叔叔和父亲变为黑色
     *  此时爷爷子树符合红黑树性质且深度不变, 但由于爷爷变为了红色可能会破坏更上层的性质, 所以需要递归维护爷爷
     * step2: 将爷爷视为刚插入的红色结点, 递归的进行维护
     */
    if (RB_Node.isRed(uncle)) {
      isDev && console.log('case3');
      console.assert(uncle !== null, "uncle should not be null when uncle is red");
      uncle!.setBlack();
      parent.setBlack();
      gparent.setRed();
      this.afterInsert(gparent);
      return;
    }

    /**
     * 叔叔为黑色(或不存在)
     */
    if (RB_Node.isBlack(uncle)) {
      /**
       * case4: 父亲为红色, 叔叔为黑色(或不存在), 且插入结点与父结点异向(LR/RL型失衡)
       * 👎p方向为左， 则对p进行左旋; 反之右旋。
       * 以左举例, p左旋后, p和n的方向都变为了左, 即同向, 此时问题转化为了case5
       *        G           G
			 *       / \         / \
			 *      p   U  -->  n   U
			 *     /  \        / \
			 *    m    n      p   q
       *        / \    / \
       *       o   q  m   o
       */

      if (parent.direction() !== node.direction()) {
        isDev && console.log('case4');
        if (node.direction() === DIRECTION.LEFT) {
          this.rotateLeft(parent);
        } else {
          this.rotateRight(parent);
        }
      }

      /**
       * case5: 父亲为红色, 叔叔为黑色(或不存在), 且插入结点与父结点同向(LL/RR型失衡)
       *
       *        (LL型失衡——右旋)
			 *        G           P
			 *       / \         / \
			 *      p   U  -->  n   g
			 *     /  \            / \
			 *    n    m          m   U
       * 
       *         (RR型失衡——左旋)
			 *        G           P
			 *       / \         / \
			 *      U   p  -->  g   n
			 *         / \     / \    
			 *        m   n   U   m     
       * 
       * 初始情况: 不符合(4)
       * step1: 基于爷爷做(LL: 右旋, RR: 左旋)
       * 此时父亲移动到了爷爷的位置, 爷爷在叔叔方向下移， 此时插入结点所在分支的黑色深度减一
       * 此时情况: 不符合(4)(5)
       * step2: 将父亲变为黑色， 爷爷变为红色
       * 爷爷所在分支黑色深度减一
       * 父亲变为黑色后， 整个子树的黑色深度加一， 插入前后的黑色深度没有变化
       * 同时p和n颜色也不同
       * 此时情况: 符合所有性质
       */
      if (parent.direction() === node.direction()) {
        isDev && console.log('case5');
        if (node.direction() === DIRECTION.LEFT) {
          // LL型失衡
          this.rotateRight(gparent);
        } else {
          // RR型失衡
          this.rotateLeft(gparent);
        }

        parent.setBlack();
        gparent.setRed();
      }
      return;
    }
    console.assert(false, "should not reach here in afterInsert");
  }

  erase(key: K) {
    // 注意此时delNode已从树中删除， 但delNode的parent、left、right等属性仍然可用
    let delNode = this.eraseNode(this.root, key, (target, source) => {
      target.key = source.key;
      target.value = source.value;
    });

    console.assert(delNode === null || delNode.key === key, "delNode should have the same key as key")
    /**
     * 当删除结点为null或者红色结点或者为树中唯一的结点时, 不需要进行调整
     */
    if (delNode === null || delNode.isRed() || this.root === null) return;

    /**
     * 删除结点为黑色结点 && 有一个孩子(必为红色)
     * 直接将孩子染黑即可
     */
    if (delNode.left || delNode.right) {
      console.assert(!(delNode.left && delNode.right), "delNode should not have two children");
      delNode.left && delNode.left.setBlack();
      delNode.right && delNode.right.setBlack();
    }
    console.log('erase Node', delNode.key, delNode.parent?.key);
    /**
     * 删除结点为黑色叶子
     */
    this.afterErase(delNode.parent!, null);
  }

  /**
   * node子树的黑色深度减一, 需要修正红黑树性质
   * @param parent 被删除结点的父结点
   * @param node 被删除的结点， 事实上node只需要用来帮助确认sibling和direction
   */
  afterErase(parent: RB_Node<K, V>, node: RB_Node<K, V> | null) {
    isDev && console.log('erase maintain');
    /**
     * node必然有siblings, 因为node子树的黑色整体减一, 说明原来的黑色深度不为0， 所以sibling子树不为空
     */
    const sibling = (parent.left === node ? parent.right : parent.left)!;
    const direction = parent.left === node ? DIRECTION.LEFT : DIRECTION.RIGHT;
    console.assert(sibling !== null, "delNode must have sibling");

    /**
     * case1: sibling为红色
     * 此时p必然为黑色, n的侄子也必然为黑色
     * 以N方向为左距离
     * 1. 就p进行左旋
     * 2. 将p染红, 将s染黑
     * 
     * 此时N的sibling为Sl为黑色, 且S子树右分支性质未破坏
     * 继续维护即可
     *     P               S
     *    / \             / \
     *   N   s    -->    p   Sr
     *      / \         / \
     *     Sl  Sr      N   Sl
     *
     *     P               S
     *    / \             / \
     *   N   s    -->    p   Sr
     *      / \         / \
     *     Sl  Sr      N   Sl
     */
    if (sibling.isRed()) {
      isDev && console.log('case1');
      if (direction === DIRECTION.LEFT) {
        this.rotateLeft(parent);
      } else {
        this.rotateRight(parent);
      }
      sibling.setBlack();
      parent.setRed();
      this.afterErase(parent, node);
      return;
    }

    // closeNephew: sibling的方向与node相同的孩子
    // distantNephew: sibling的方向与node相反的孩子
    const closeNephew = sibling.direction() === DIRECTION.RIGHT ? sibling.left : sibling.right;
    const distantNephew = sibling.direction() === DIRECTION.RIGHT ? sibling.right : sibling.left;
    
    if (RB_Node.isBlack(closeNephew) && RB_Node.isRed(distantNephew)) {
      sibling.setRed();
      /**
       * case2: sibling为黑色 && sibling的两个子结点都为黑色 && parent为红色
       * 将sibling染红, parent染黑即可
       * sibling分支的黑色数量不变, node分支的黑色数量+1抵消了node删除后减1
       */
      if (parent.isRed()) {
        isDev && console.log('case2');
        parent.setBlack();
        return;
      }
      /**
       * case3: sibling为黑色 && sibling的两个子结点都为黑色 && parent为黑色
       * 将sibling染红, 此时parent子树整体黑色深度减一, 将parent看作被删除的node, 递归维护
       */
      isDev && console.log('case3');
      this.afterErase(parent.parent!, parent);
      return;
    }

    /**
     * case4: closeNephew为红色, distantNephew为黑色
     * 基于sibling进行旋转, 转化为case5
     */
    if (RB_Node.isRed(closeNephew) && RB_Node.isBlack(distantNephew)) {
      isDev && console.log('case4');
      console.assert(closeNephew !== null, "closeNephew should not be null when closeNephew is red")
      if (sibling.direction() === DIRECTION.LEFT) {
        this.rotateRight(sibling);
      } else {
        this.rotateLeft(sibling);
      }
      closeNephew?.setBlack();
      sibling.setRed();
      this.afterErase(parent, node);
      return;
    }

    /**
     * case5: closeNephew为黑色或红色, distantNephew为红色
     * 1. 基于parent进行旋转
     * 2. 将sibling的颜色变为parent的颜色, parent和distantNephew变为黑色
     */
    if (RB_Node.isRed(distantNephew)) {
      isDev && console.log('case5');
      console.assert(distantNephew !== null, "distantNephew should not be null when distantNephew is red");
      if (sibling.direction() === DIRECTION.RIGHT) {
        this.rotateLeft(parent);
      } else {
        this.rotateRight(parent);
      }
      sibling.color = parent.color;
      parent.setBlack();
      distantNephew && distantNephew.setBlack();
    }
  }

  show() {
    this.Traversal(this.root, (node) => {
      node.left && console.log(`${node.key}(${node.color}) --(left)--> ${node.left.key}(${node.left.color})`);
      node.right && console.log(`${node.key}(${node.color}) --(right)--> ${node.right.key}(${node.right.color})`);
    });
  }
}
```

