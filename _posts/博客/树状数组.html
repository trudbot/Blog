<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>树状数组 | Trudbot's Blog</title>
    <meta name="description" content="trudbot的博客">
    <meta name="generator" content="VitePress v1.3.4">
    <link rel="preload stylesheet" href="/assets/style.B5ZaEiKx.css" as="style">
    
    <script type="module" src="/assets/app.gLVttrAp.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/assets/chunks/framework.C2eWyT4L.js">
    <link rel="modulepreload" href="/assets/chunks/transform.Bg681GEu.js">
    <link rel="modulepreload" href="/assets/chunks/theme.CLQbywMn.js">
    <link rel="modulepreload" href="/assets/chunks/katex.rPiVaalG.js">
    <link rel="modulepreload" href="/assets/chunks/c4Diagram-ae766693.TflLXyGm.js">
    <link rel="modulepreload" href="/assets/chunks/flowDiagram-b222e15a.DHDShYSX.js">
    <link rel="modulepreload" href="/assets/chunks/flowDiagram-v2-13329dc7.BsAkKJj9.js">
    <link rel="modulepreload" href="/assets/chunks/erDiagram-09d1c15f.jsf949iB.js">
    <link rel="modulepreload" href="/assets/chunks/gitGraphDiagram-942e62fe.D-17dJJf.js">
    <link rel="modulepreload" href="/assets/chunks/ganttDiagram-b62c793e.BrPLmMRX.js">
    <link rel="modulepreload" href="/assets/chunks/infoDiagram-94cd232f.CfJcgLrf.js">
    <link rel="modulepreload" href="/assets/chunks/pieDiagram-bb1d19e5.Ciof58sS.js">
    <link rel="modulepreload" href="/assets/chunks/quadrantDiagram-c759a472.BISY2_Qc.js">
    <link rel="modulepreload" href="/assets/chunks/xychartDiagram-f11f50a6.GrFAqlkE.js">
    <link rel="modulepreload" href="/assets/chunks/requirementDiagram-87253d64.CmMgbqkb.js">
    <link rel="modulepreload" href="/assets/chunks/sequenceDiagram-6894f283.BZY8i4Gi.js">
    <link rel="modulepreload" href="/assets/chunks/classDiagram-fb54d2a0.DOkScZZW.js">
    <link rel="modulepreload" href="/assets/chunks/classDiagram-v2-a2b738ad.2xVnVe9Z.js">
    <link rel="modulepreload" href="/assets/chunks/stateDiagram-5dee940d.B0Kj6qiC.js">
    <link rel="modulepreload" href="/assets/chunks/stateDiagram-v2-1992cada.DEYqnqMX.js">
    <link rel="modulepreload" href="/assets/chunks/journeyDiagram-6625b456.ByhgGqHk.js">
    <link rel="modulepreload" href="/assets/chunks/flowchart-elk-definition-ae0efee6.CHhfHO8L.js">
    <link rel="modulepreload" href="/assets/chunks/timeline-definition-bf702344.BdRU6hR3.js">
    <link rel="modulepreload" href="/assets/chunks/mindmap-definition-307c710a.DmmaX7SF.js">
    <link rel="modulepreload" href="/assets/chunks/sankeyDiagram-707fac0f.C_jNJ0Gr.js">
    <link rel="modulepreload" href="/assets/chunks/blockDiagram-9f4a6865.Cv1WGpDs.js">
    <link rel="modulepreload" href="/assets/chunks/virtual_mermaid-config.DDnGl6nM.js">
    <link rel="modulepreload" href="/assets/posts_博客_树状数组.md.Br5ekCvF.lean.js">
    <link rel="icon" href="https://trudbot-md-img.oss-cn-shanghai.aliyuncs.com/202407082112768.jpg">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle has-sidebar" data-v-9fd4d1dd data-v-0ad69264><a class="title" href="/" data-v-0ad69264><!--[--><!--]--><!--[--><img class="VPImage logo" src="https://trudbot-md-img.oss-cn-shanghai.aliyuncs.com/202311131854196.webp" alt data-v-ab19afbb><!--]--><span data-v-0ad69264>Trudbot&#39;s Blog</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/" tabindex="0" data-v-afb2845e data-v-08fbf4b6><!--[--><span data-v-08fbf4b6>Home</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/about.html" tabindex="0" data-v-afb2845e data-v-08fbf4b6><!--[--><span data-v-08fbf4b6>About</span><!--]--></a><!--]--><!--[--><a class="VPLink link vp-external-link-icon VPNavBarMenuLink" href="https://www.zhihu.com/people/qu-ge-sha-ming-hao-ni-30" target="_blank" rel="noreferrer" tabindex="0" data-v-afb2845e data-v-08fbf4b6><!--[--><span data-v-08fbf4b6>ZhiHu</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/trudbot" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-358b6670><span class="vpi-social-github" /></a><a class="VPSocialLink no-icon" href="https://www.npmjs.com/org/trudbot" aria-label="npm" target="_blank" rel="noopener" data-v-e71e869c data-v-358b6670><span class="vpi-social-npm" /></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-af5898d3><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-af5898d3><span class="vpi-more-horizontal icon" data-v-af5898d3></span></button><div class="menu" data-v-af5898d3><div class="VPMenu" data-v-af5898d3 data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>Appearance</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/trudbot" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-358b6670><span class="vpi-social-github" /></a><a class="VPSocialLink no-icon" href="https://www.npmjs.com/org/trudbot" aria-label="npm" target="_blank" rel="noopener" data-v-e71e869c data-v-358b6670><span class="vpi-social-npm" /></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2488c25a><span class="vpi-align-left menu-icon" data-v-2488c25a></span><span class="menu-text" data-v-2488c25a>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>返回顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-d8b57b2d data-v-42c4c606><div class="curtain" data-v-42c4c606></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-42c4c606><span class="visually-hidden" id="sidebar-aria-label" data-v-42c4c606> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>Haskell</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/Haskell/README.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>README</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/Haskell/3.%20%E9%80%92%E5%BD%92%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%9A%E6%80%81.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>3. 递归模式和多态</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/Haskell/2.%20%E4%BB%A3%E6%95%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>2. 代数数据类型</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/Haskell/1.%20Haskell%E7%AE%80%E4%BB%8B.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>1. Haskell简介</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed has-active" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>博客</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/Readme.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>认识一下吧</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/%E5%88%9D%E5%B0%9DWeb%20Components.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>初尝Web Components</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/3%E5%AD%97%E8%8A%82%E6%B5%AE%E7%82%B9%E6%95%B0.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>3字节浮点数</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/%E7%BA%A2%E9%BB%91%E6%A0%91.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>红黑树</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/vue%E7%BB%84%E4%BB%B6%E5%92%8C%E6%8F%92%E6%A7%BD%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8F%8C%E5%90%91%E9%80%9A%E4%BF%A1.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>vue组件和插槽之间的通信</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/git-commit-message-%E8%A7%84%E8%8C%83.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>git commit message 规范</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/nest%E4%B8%AD%E4%BD%BF%E7%94%A8websocket.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>nest中使用websocket</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/RMQ.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>RMQ</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/2023-RoboCom-%E4%B8%96%E7%95%8C%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E8%B5%9B-%E6%9C%AC%E7%A7%91%E7%BB%84-%E7%9C%81%E8%B5%9B-CAIP-%E9%A2%98%E8%A7%A3.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>2023 RoboCom 世界机器人开发者大赛-本科组 (省赛) CAIP 题解</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/FFT.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>FFT</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%AE%B0%E5%BD%95.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>博客迁移记录</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AFC-C-B%E7%BB%84%E5%9B%BD%E8%B5%9B.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>第十四届蓝桥杯C/C++B组国赛</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/%E5%93%88%E5%AF%86%E9%A1%BF%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>哈密顿路径问题</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AFC-C-B%E7%BB%84%E7%9C%81%E8%B5%9B.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>第十四届蓝桥杯C/C++B组省赛</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/%E5%80%8D%E5%A2%9ELCA.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>倍增LCA</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>概率论与数理统计</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>树状数组</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/%E5%9B%BE%E7%9D%80%E8%89%B2.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>图着色</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%89%8B%E5%86%8C.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>latex数学公式手册</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/%E7%BB%84%E5%90%88%E6%95%B0.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>组合数</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>乘法逆元</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E5%92%8C%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>欧几里得算法和扩展欧几里得算法</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/%E7%B4%A0%E6%80%A7%E6%A3%80%E9%AA%8C.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>素性检验</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>欧拉路径问题</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>矩阵快速幂</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/%E9%AB%98%E7%B2%BE%E5%BA%A6%E6%A8%A1%E6%9D%BF.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>高精度模板</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>最短路算法</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>排序算法</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/%E7%BA%BF%E6%AE%B5%E6%A0%91.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>线段树</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>二分查找</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>字符串哈希</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/%E4%B8%80%E6%96%87%E6%90%9E%E5%AE%9Acpp%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>一文搞定c++自定义排序</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E5%8D%9A%E5%AE%A2/%E6%9C%89%E7%82%B9%E5%AD%A6%E9%97%AE%E7%9A%84%E7%BC%A9%E8%BF%9B%E9%A3%8E%E6%A0%BC.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>有点学问在的缩进风格</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>笔记</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><section class="VPSidebarItem level-1 collapsible" data-v-edd2eed8 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h3 class="text" data-v-edd2eed8>浏览器原理</h3><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-2 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E7%AC%94%E8%AE%B0/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>渲染进程如何工作</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E7%AC%94%E8%AE%B0/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>浏览器多进程架构</p><!--]--></a><!----></div><!----></div><!--]--></div></section><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>转载|收藏</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><section class="VPSidebarItem level-1 collapsible" data-v-edd2eed8 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h3 class="text" data-v-edd2eed8>Lambda Calculus</h3><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-2 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E8%BD%AC%E8%BD%BD|%E6%94%B6%E8%97%8F/Lambda%20Calculus/README.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>README</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E8%BD%AC%E8%BD%BD|%E6%94%B6%E8%97%8F/Lambda%20Calculus/2.%20The%20Genius%20of%20Alonzo%20Church:%20Numbers%20in%20Lambda%20Calculus.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>2. The Genius of Alonzo Church: Numbers in Lambda Calculus</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E8%BD%AC%E8%BD%BD|%E6%94%B6%E8%97%8F/Lambda%20Calculus/1.%20My%20Favorite%20Calculus:%20Lambda%20(part%201).html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>1. My Favorite Calculus: Lambda (part 1)</p><!--]--></a><!----></div><!----></div><!--]--></div></section><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/_posts/%E8%BD%AC%E8%BD%BD|%E6%94%B6%E8%97%8F/free-programming-books.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>free-programming-books</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-sidebar has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>On this page</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc __posts_%E5%8D%9A%E5%AE%A2_%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84" data-v-e6f2a212><div><blockquote><p>转载至 <a href="https://www.hackerearth.com/practice/notes/binary-indexed-tree-made-easy-2/" target="_blank" rel="noreferrer">骇客地球</a></p><p>树状数组的代码很简单， 但思想却很复杂</p><p>搞清楚每一句代码背后的细节， 私以为是很重要的</p><p>这篇文章从一个新的角度，讲述树状数组实际上在做什么</p></blockquote><p>For the past few days, I have been reading various explanations of the Binary Indexed Tree. For some reason, none of the explanations were doing it for me. All explanations told me the same thing over and over again. I was not able to find the motive behind this data structure, intuition behind this data structure.</p><p>Finally, I decided to sit down, check some examples, diagram them out, check stack overflow and understand it. I now understand the beauty of this data structure, and I think, I can explain it. For those who have gone through this and also for those who don&#39;t want to go through this phase, I am writing this post..</p><p>Let me tell you one thing, this is going to be a longer post. I will try to cover all the things associated with it. I have included examples for understanding. Give it half an hour, you will surely get new thing to learn.</p><p>Wasting no time, lets have a well defined problem.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>We will be given an array. And we are asked to answer few queries. </span></span>
<span class="line"><span>Queries will be of two types:-</span></span>
<span class="line"><span>1) Update X Y : Increment value at Xth index by Y.</span></span>
<span class="line"><span>2) Sum L R : Print sum of values at index L to R inclusive.</span></span></code></pre></div><p>Lets have a look at other approaches in short, before going for BIT (Binary Indexed Tree), so that you will know the need of BIT.</p><ol><li>We can <strong>update</strong> any value in the array in single step. So, update operation will need time<code>O(1)</code>. Also, for <strong>sum</strong> operation, we can traverse the array and find sum. That operation will take time <code>O(n)</code>in worst case.</li><li>One more thing we can do. At each index, we will store the cumulative frequency i.e. we will store sum of all elements before it including itself. We can construct this new array in . Lets say this array as CF[]. After that, All the <strong>sum</strong> operation will take time since we will just subtract CF[L-1] from CF[R] to get the answer for sum L R. But well, we will need to construct CF[] or at least update CF[] every-time update operation is made. The worst case time required for this will be .</li></ol><p>Since, the queries are huge in number, we can not always afford time complexity <code>O(n)</code>too. So, here comes the BIT for our rescue.</p><hr><h2 id="binary-indexed-tree-or-fenwick-tree" tabindex="-1"><strong>BINARY INDEXED TREE</strong> or <strong>FENWICK TREE</strong> <a class="header-anchor" href="#binary-indexed-tree-or-fenwick-tree" aria-label="Permalink to &quot;**BINARY INDEXED TREE** or **FENWICK TREE**&quot;">​</a></h2><p><strong>CONSTRUCTION of BIT:</strong></p><p>Lets have an example with us. Input array is:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[ 5 ] [ 1 ] [ 6 ] [ 4 ] [ 2 ] [ 3 ] [ 3 ]</span></span>
<span class="line"><span>  1     2     3     4     5     6     7</span></span></code></pre></div><p>Now, think of what we did in 2nd approach. For each index, we were storing sum of all elements before that element to that index. Right? But because of that, we were needed to change values at all locations for every update.</p><p>Now think it this way, what if we store sum of some elements at each index? i.e. Each index will store sum of some elements the number may vary. Similarly, for update operation also, we will need to update only few values, not all. We will see how!</p><p>Formally, we will create some benchmarks. Each benchmark will store sum of all elements before that element; but other than those benchmarks, no other point will store sum of all elements, they will store sum of few elements. Okay, if we can do this, what we will need to do to get sum at any point is - intelligently choosing right combination of positions so as to get sum of all elements before that point. And then we will extend it to sum of elements from L to R (for this, the approach will be same as we did in second approach). We will see that afterwards.</p><p>Now, having done the base work, lets move ahead.</p><p>Before telling HOW will we be doing, I would like to tell you WHAT are we going to do. To remind you, we are going to create BIT[] of given input array.</p><p><strong>WHAT:</strong></p><p>This is a kind of manual process I am showing.</p><p>The benchmarks I was talking about are the powers of 2. Each index, if it is a power of 2, will store the sum of all elements before that. And we will apply this repetitively so as to get what each index will store.</p><p>Suppose, we have an array of 16 elements, [1 .. 16].</p><p>Powers of 2 are:- 1, 2, 4, 8, 16</p><p>These index will store sum of all elements before them.</p><p>Fine?</p><p>What about others?</p><p>Divide this array in two halves:- we get [1..8] and [9 .. 16].</p><p>Now think recursively what we did for array of 16, apply same for this, okay?</p><p>Seems like little bouncer? Wait, have an example of 8 elements only. Say 8 elements are :</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>1   2   3   4   5   6   7   8</span></span></code></pre></div><p>Ok, powers of 2 are: 1 2 4 8 so, in BIT[] indiced 1 2 4 8 will store 1 = 1, 1 + 2 =3, 1 + 2 + .. + 4 = 10 and 1 + 2 + .. + 8 = 36 respectively. Right? Remember, sum of all elements before that element? Right? Good. So, till now, BIT looks like this:-</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[ 1 ] [ 3 ] [  ] [ 10 ] [   ] [   ] [  ] [36] </span></span>
<span class="line"><span>  1    2    3    4    5     6    7   8</span></span></code></pre></div><p>Now, divide the given array in 2 halves.</p><p>Arr1:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>1   2   3   4</span></span></code></pre></div><p>Arr2:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>5   6   7   8</span></span></code></pre></div><p>Consider Arr1 first. Powers of 2 are:- 1 2 4 They already have their right values, no need to update.</p><p>Now, Consider Arr2: Powers of 2 are: 1 2 4</p><p>So, at indices 1, 2 and 4 will store 5 = 5, 5 + 6 = 11, 5 + 6 + 7 + 8 = 26 respectively.</p><p>These are the indices according to this new 4-element array. So, actual indices with respect to original array are 4+1, 4+2, 4+4 i.e. 5, 6, 8. We will not care about index 8 as it is already filled in BIT[]. Hence we will update position 5 and 6 now.</p><p>BIT will start looking like this now:-</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[ 1 ] [ 3 ] [  ] [ 10 ] [ 5 ] [ 11 ] [  ] [ 36 ] </span></span>
<span class="line"><span>  1     2     3    4      5     6      7    8</span></span></code></pre></div><p>I think you guys have got what we are doing. Applying same procedure on Arr1 and Arr2, we will get 4 - two element arrays (2 from Arr1 and 2 from Arr2). Follow the same procedure, don&#39;t change the value at any index if it is already filled, you get this BIT finally.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[ 1 ] [ 3 ] [ 3 ] [ 10 ] [ 5 ] [ 11 ] [ 7 ] [ 36 ] </span></span>
<span class="line"><span>  1     2     3     4      5     6      7     8</span></span></code></pre></div><p>Guys, do take an example of 16 element array and convert it to BIT manually to get the gist.</p><p>Now see how will we do this in program.</p><p><strong>HOW:</strong></p><p>We will continue with our previous example.</p><p>Now, start thinking of our array as a binary tree, like this:-</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>BEFORE:</span></span>
<span class="line"><span>[ 5 ] [ 1 ] [ 6 ] [ 4 ] [ 2 ] [ 3 ] [ 3 ]</span></span>
<span class="line"><span>  1     2     3     4     5     6     7</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NOW:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>         4</span></span>
<span class="line"><span>       [ 4 ]</span></span>
<span class="line"><span>      /     \</span></span>
<span class="line"><span>     2       6</span></span>
<span class="line"><span>   [ 1 ]   [ 3 ]</span></span>
<span class="line"><span>    / \     / \</span></span>
<span class="line"><span>   1   3   5   7</span></span>
<span class="line"><span>  [5] [6]  [2] [3]</span></span></code></pre></div><p>Now, we will change value at each node by adding the sum of nodes in its <strong>left sub-tree</strong>.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>UPDATED VERSION:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>         4</span></span>
<span class="line"><span>       [ 16 ]</span></span>
<span class="line"><span>      /     \</span></span>
<span class="line"><span>     2       6</span></span>
<span class="line"><span>   [ 6 ]   [ 5 ]</span></span>
<span class="line"><span>    / \     / \</span></span>
<span class="line"><span>   1   3   5   7</span></span>
<span class="line"><span>  [5] [6]  [2] [3]</span></span></code></pre></div><p>I think you have got what we have just done! Take each node, find sum of all nodes in its left sub-tree and add it to value of that node. And this is what we call is BIT.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>BIT:</span></span>
<span class="line"><span>[ 5 ] [ 6 ] [ 6 ] [ 16 ] [ 2 ] [ 5 ] [ 3 ]</span></span>
<span class="line"><span>  1     2     3     4      5     6     7</span></span></code></pre></div><hr><p><strong>SUM and UPDATE operations:</strong></p><p>Now, we have got the BIT. Lets move ahead and solve our real problem.</p><p>Having this tree structure with us, it is to find sum of elements till any index. The idea is to keep a variable <code>ans</code> initialized to 0. Follow the path from root to the node <code>index</code>. Whenever we need to follow a right link, add the value of current node to <code>ans</code> . Once we reach the node, add that value too.</p><p>For example, If we want sum of elements upto index 3.</p><p>See again,</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>INPUT ARRAY is:</span></span>
<span class="line"><span>[ 5 ] [ 1 ] [ 6 ] [ 4 ] [ 2 ] [ 3 ] [ 3 ]</span></span>
<span class="line"><span>  1     2     3     4     5     6     7</span></span></code></pre></div><p>(so answer should come out as 5 + 1 + 6 = 12)</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>BIT is:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>         4</span></span>
<span class="line"><span>       [ 16 ]</span></span>
<span class="line"><span>      /     \</span></span>
<span class="line"><span>     2       6</span></span>
<span class="line"><span>   [ 6 ]   [ 5 ]</span></span>
<span class="line"><span>    / \     / \</span></span>
<span class="line"><span>   1   3   5   7</span></span>
<span class="line"><span>  [5] [6]  [2] [3]</span></span></code></pre></div><p>Following the procedure given above.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>1&gt; node = root, ans = 0</span></span>
<span class="line"><span>2&gt; node is 4, index is 3. </span></span>
<span class="line"><span>3&gt; index &lt; node, go left</span></span>
<span class="line"><span>4&gt; node = 2, index is 3.</span></span>
<span class="line"><span>5&gt; index &gt; node, add value(node) to ans and go right</span></span>
<span class="line"><span>      i.e. ans = ans + value(node 2)</span></span>
<span class="line"><span>      i.e. ans = 0 + 6</span></span>
<span class="line"><span>      i.e. ans = 6</span></span>
<span class="line"><span>      Now, go right</span></span>
<span class="line"><span>6&gt; node = 3, index = 3</span></span>
<span class="line"><span>7&gt; node == index, add value of node 3 to ans and return ans</span></span>
<span class="line"><span>     i.e. ans = ans + 6</span></span>
<span class="line"><span>     i.e. ans = 12</span></span>
<span class="line"><span>     return 12</span></span></code></pre></div><p>In actual implementation, we will be following the reverse path i.e. from node to root.</p><p>We will go in actual implementation too. Just have look at update operation as well.</p><p>If we want to increment <code>k</code> the value at <code>index</code> by say .</p><p>The idea is very similar to sum operation.</p><p>Follow the path from root to the node. Whenever we need to follow a left link, add the value of to current node. Once we reach the node, add to that node too. This is because we will need to update the set of nodes in the tree that include that node in its left subtree, so that it will be consistent with our sum operation, right?<code>index``k``k</code></p><p>I don&#39;t think there is any need of example for this case again.</p><hr><p>Moving ahead to the implementation.</p><p>For this, we will play a bit with <strong>BITS -- Binary Numbers</strong>. Here comes the fun with bits -- Binary numbers. You will have to do little more work here to figure out the things. I will try my best though.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>TREE is:</span></span>
<span class="line"><span>        100</span></span>
<span class="line"><span>       [ 16 ]</span></span>
<span class="line"><span>      /     \</span></span>
<span class="line"><span>    010     110</span></span>
<span class="line"><span>   [ 6 ]   [ 5 ]</span></span>
<span class="line"><span>    / \     / \</span></span>
<span class="line"><span>  001 011 101 111</span></span>
<span class="line"><span>  [5] [6] [2] [3]</span></span></code></pre></div><p>We have just changed the representation of out indices to binary. Ok?</p><p>Now, For each index, find the right most SET-bit i.e. &#39;1&#39; and drop the all zeros along with that &#39;1&#39;. We get,</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>       (--)</span></span>
<span class="line"><span>      [ 16 ]</span></span>
<span class="line"><span>      /     \</span></span>
<span class="line"><span>     0       1</span></span>
<span class="line"><span>   [ 6 ]    [ 5 ]</span></span>
<span class="line"><span>    / \      / \</span></span>
<span class="line"><span>  00   01   10  11</span></span>
<span class="line"><span>  [5]  [6]  [2] [3]</span></span></code></pre></div><p>Here is the thing to be observed. If we treat 0 as LEFT and 1 as RIGHT, each node tells you the path to be followed from root to reach that node. Really? Have example, say node 5, which has 10 there, i.e. RIGHT and LEFT. This is the path we need to follow from root to 5. Cool thing, right?</p><p>The reason why this is important to us is, our <strong>sum</strong> and <strong>update</strong> operations depends on the this path. Are they not? You remember, Left link, right link, right? During a <strong>sum</strong>, we just care about the left links we follow. During an <strong>update</strong>, we just care about the right links we follow. This binary indexed tree does all of this super efficiently by just using the bits in the index.</p><p>The key thing behind the efficiency of BIT is:</p><blockquote><p>Given any index n, the next node on the path from root to that index where we go right is directly calculated by RESETing i.e. &#39;0&#39; the last (right most) SET-bit from the binary representation of . Apply this until we reach the root.<code>index</code></p></blockquote><p>Lets have examples:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>TREE is:</span></span>
<span class="line"><span>         4</span></span>
<span class="line"><span>       [ 16 ]</span></span>
<span class="line"><span>      /     \</span></span>
<span class="line"><span>     2       6</span></span>
<span class="line"><span>   [ 6 ]   [ 5 ]</span></span>
<span class="line"><span>    / \     / \</span></span>
<span class="line"><span>   1   3   5   7</span></span>
<span class="line"><span>  [5] [6] [2]  [3]</span></span></code></pre></div><p>Say index is 5. The path from 4 to 5 is [ 4 -&gt; RIGHT -&gt; 6 -&gt; LEFT -&gt; 5 ] i.e. we take RIGHT at 4. Binary Representation of 5 is 101. RESET right-most SET-bit. 101 -&gt; 100 4 is the one node from where we will go right STOP here. We have reached the root.</p><p>Say index is 7. The path from 4 to 7 is [ 4 -&gt; RIGHT -&gt; 6 -&gt; RIGHT -&gt; 7 ] i.e. we take RIGHT at 4 and 6. Binary Representation of 7 is 111. RESET right-most SET-bit. 111 -&gt; 110 6 is the node from where we will go right RESET right-most SET-bit. 110 -&gt; 100 4 is the node from where we will go right STOP here. We have reached the root.</p><p>We will use this information in our implementation.</p><p><strong>Implementation:</strong></p><p>Now we know, how to go from any index to the root and find what all right-links come in our path.</p><p>I will repeat some part of what we have looked.</p><blockquote><p>For SUM: The idea is to keep a variable initialized to 0. Follow the path from root to the node. Whenever we need to follow a right link, add the value of current node to . Once we reach the node, add that value too.<code>ans``index``ans</code></p><p>For UPDATE: Follow the path from root to the node. Whenever we need to follow a left link, add the value of to current node. Once we reach the node, add to that node too.<code>index``k``k</code></p></blockquote><p>Now you have got the complete picture I guess. Everything of What we saw, Why we saw?</p><p>For SUM, We need to follow RIGHT-links no matter from root to index or reverse. And we also know how to do that. Right?</p><p>So algorithm is:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SUM(index):</span></span>
<span class="line"><span>    ans = 0</span></span>
<span class="line"><span>    while(index != 0):</span></span>
<span class="line"><span>        ans += BIT[index]</span></span>
<span class="line"><span>        index = Reset_Rightmost_SET_bit(index)</span></span>
<span class="line"><span>    return ans</span></span></code></pre></div><p>Now, the thing remain unanswered is: How to Reset rightmost SETbit? This is a very simple task which I have already covered in my this note. By some observations, we can arrive at a conclusion that, whenever we subtract one from any number say n, the part before a right-most set bit remain same while part after right-most set bit gets inverted. So, just ANDing these can solve our problem.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Reset_Rightmost_SET_bit(n):</span></span>
<span class="line"><span>    return n&amp;(n-1)</span></span></code></pre></div><p>Please be focused and try to understand this.</p><p>We need all left links but we can only know right links with the technique we studied earlier.</p><p>We know that, dropping the right-most SET bit and part after that gives us the path from root to node.</p><p>So, zeros which come after the right-most one are not useful to us at all.</p><p>We will use both these fact and try to find a way.</p><p>You must have observed, what happens when we add a 1 to right-most SET bit of a number? [Consider scan from right to left]</p><ol><li>The first zero from right (which will come after i.e. left to, right-most ONE of number) turns into one</li><li>Part after (i.e. left to) that ZERO remain unchanged and Part before that get inverted.</li></ol><p>Is this not the exact reverse procedure of what used to happen in SUM operation.</p><p>This is all what we wanted!</p><p>And this is the value i.e. index from which we needed to take the left link to reach to our node from root.</p><p>We have successfully found the left link too.</p><p>Adding one to right most one is nothing but adding place value of right-most ONE to the number.</p><p>Hence our Update operation is as simple as:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>UPDATE(index, addition):</span></span>
<span class="line"><span>    while(index &lt; length_of_array):</span></span>
<span class="line"><span>        BIT[index] += addition</span></span>
<span class="line"><span>        index = index + (index &amp; -index)</span></span></code></pre></div><p>Try to check the similarity and difference, and you will never forget again.</p><p>Here I will stop. I guess you have everything what you need to know about Binary Indexed Tree as a data structure. Now I advice you to implement it yourself and see if you can do it.</p><p>You can always refer to the code which I am providing you.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># About using the 2 functions:-</span></span>
<span class="line"><span># For update, pass index of location to be updated, input array, BIT, value to be added to original number</span></span>
<span class="line"><span># i.e. new value - original value</span></span>
<span class="line"><span># For getting sum of elements in range l to r,</span></span>
<span class="line"><span># Getsum returns sum of elements from beginning to index</span></span>
<span class="line"><span># Pass index, input array &amp; BIT to function</span></span>
<span class="line"><span># getsum of l to r = getsum of r - getsum of (l-1)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>def update(index, a, tree, value):</span></span>
<span class="line"><span># index is index to be updated, a is input array / list, tree is BIT array, value is value to be added to original </span></span>
<span class="line"><span># number at index location</span></span>
<span class="line"><span>    add = value</span></span>
<span class="line"><span>    n = len(a)</span></span>
<span class="line"><span>    while index&lt;n:</span></span>
<span class="line"><span>        tree[index] += add</span></span>
<span class="line"><span>        index = index + (index &amp; (-index))</span></span>
<span class="line"><span></span></span>
<span class="line"><span>def getsum(index, a, tree):</span></span>
<span class="line"><span># index is location upto which you want the sum of elements from beginning</span></span>
<span class="line"><span># tree is BIT[], a is input array / list</span></span>
<span class="line"><span>    n = len(a)</span></span>
<span class="line"><span>    ans  = 0</span></span>
<span class="line"><span>    while(index&gt;0):</span></span>
<span class="line"><span>        ans += tree[index]</span></span>
<span class="line"><span>        index = index - (index &amp; (-index))</span></span>
<span class="line"><span>    return ans</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#Get the user input</span></span>
<span class="line"><span>n = int(raw_input(&quot;Number of Elements in array: &quot;))</span></span>
<span class="line"><span>inputArray = list(map(int, raw_input(&quot;Elements in array: &quot;).split()))</span></span>
<span class="line"><span>inputArray.insert(0,0)                 # insert dummy node to have 1-based indexing</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#Initialise Binary Indexed Tree to 0&#39;s considering that input array is all 0&#39;s</span></span>
<span class="line"><span>BIT = []</span></span>
<span class="line"><span>for i in range(0, n):</span></span>
<span class="line"><span>    BIT.append(0)</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Now we will construct actual BIT</span></span>
<span class="line"><span># The 4th parameter is always an additional value which is to be added to element at index location</span></span>
<span class="line"><span># since we have considered input array as 0 earlier (while initialising BIT), for updating, we will pass actual </span></span>
<span class="line"><span># value</span></span>
<span class="line"><span>for i in range(1, n):</span></span>
<span class="line"><span>    update(i, inputArray, BIT, inputArray[i])</span></span></code></pre></div><p>If you like this, Let me know 😃 Like, Share, Upvote[at the top]!!</p><p>Thank you for reading and also thanks for your patience.</p></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><div class="edit-info" data-v-1bcd8184><!----><div class="last-updated" data-v-1bcd8184><p class="VPLastUpdated" data-v-1bcd8184 data-v-1bb0c8a8>最后更新于: <time datetime="2024-06-16T06:54:54.000Z" data-v-1bb0c8a8></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link prev" href="/_posts/%E5%8D%9A%E5%AE%A2/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>Previous page</span><span class="title" data-v-1bcd8184>概率论与数理统计</span><!--]--></a></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/_posts/%E5%8D%9A%E5%AE%A2/%E5%9B%BE%E7%9D%80%E8%89%B2.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>Next page</span><span class="title" data-v-1bcd8184>图着色</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"about.md\":\"CZV36l2C\",\"index.md\":\"CO8kSKbj\",\"posts_haskell_1. haskell简介.md\":\"vTWDmW_r\",\"posts_haskell_2. 代数数据类型.md\":\"DWiQiOaA\",\"posts_haskell_3. 递归模式和多态.md\":\"G2Bs50Au\",\"posts_haskell_readme.md\":\"Cn6rcS_M\",\"posts_博客_2023-robocom-世界机器人开发者大赛-本科组-省赛-caip-题解.md\":\"B95ToXSb\",\"posts_博客_3字节浮点数.md\":\"Cn8I_2Dt\",\"posts_博客_fft.md\":\"CoH17pEK\",\"posts_博客_git-commit-message-规范.md\":\"Ba6llC43\",\"posts_博客_hexo博客迁移记录.md\":\"C3uWNLLx\",\"posts_博客_latex数学公式手册.md\":\"DLxvndKL\",\"posts_博客_nest中使用websocket.md\":\"KW5J_fF7\",\"posts_博客_readme.md\":\"Wt0jPmUa\",\"posts_博客_rmq.md\":\"CwBEdQ5W\",\"posts_博客_vue组件和插槽之间的双向通信.md\":\"CaQs6mpm\",\"posts_博客_一文搞定cpp自定义排序.md\":\"B223KwqL\",\"posts_博客_乘法逆元.md\":\"CFje1SeE\",\"posts_博客_二分查找.md\":\"0ni3i9Am\",\"posts_博客_倍增lca.md\":\"JEW_fbQZ\",\"posts_博客_初尝web components.md\":\"DpledY_r\",\"posts_博客_哈密顿路径问题.md\":\"DHLDxLwj\",\"posts_博客_图着色.md\":\"CP7NuzbE\",\"posts_博客_字符串哈希.md\":\"BdIpZe0a\",\"posts_博客_排序算法.md\":\"2hOzQyq6\",\"posts_博客_最短路算法.md\":\"I8qca98I\",\"posts_博客_有点学问的缩进风格.md\":\"BOdoM38r\",\"posts_博客_树状数组.md\":\"Br5ekCvF\",\"posts_博客_概率论与数理统计.md\":\"CggmHEjy\",\"posts_博客_欧几里得算法和扩展欧几里得算法.md\":\"CWFzka8G\",\"posts_博客_欧拉路径问题.md\":\"DoVEVVV0\",\"posts_博客_矩阵快速幂.md\":\"DH6t_p6g\",\"posts_博客_第十四届蓝桥杯c-c-b组国赛.md\":\"CQLnyHVH\",\"posts_博客_第十四届蓝桥杯c-c-b组省赛.md\":\"BQv2J9u8\",\"posts_博客_素性检验.md\":\"Q_ErmSs9\",\"posts_博客_红黑树.md\":\"DrpxRSQC\",\"posts_博客_线段树.md\":\"5sHP1GVV\",\"posts_博客_组合数.md\":\"BUMp4_2y\",\"posts_博客_高精度模板.md\":\"kxuO4hQO\",\"posts_笔记_浏览器原理_浏览器多进程架构.md\":\"DKQxibG_\",\"posts_笔记_浏览器原理_渲染进程如何工作.md\":\"CC37UAED\",\"posts_转载_收藏_free-programming-books.md\":\"CR6z4v9k\",\"posts_转载_收藏_lambda calculus_1. my favorite calculus_ lambda (part 1).md\":\"Qqow9jt6\",\"posts_转载_收藏_lambda calculus_2. the genius of alonzo church_ numbers in lambda calculus.md\":\"BHrQjGmq\",\"posts_转载_收藏_lambda calculus_readme.md\":\"CMxg10g5\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"Trudbot's Blog\",\"description\":\"trudbot的博客\",\"base\":\"/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"logo\":\"https://trudbot-md-img.oss-cn-shanghai.aliyuncs.com/202311131854196.webp\",\"nav\":[{\"text\":\"Home\",\"link\":\"/\"},{\"text\":\"About\",\"link\":\"/about\"},{\"text\":\"ZhiHu\",\"link\":\"https://www.zhihu.com/people/qu-ge-sha-ming-hao-ni-30\"}],\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"full\",\"timeStyle\":\"medium\"}},\"sidebar\":[{\"text\":\"Haskell\",\"items\":[{\"text\":\"README\",\"link\":\"/_posts/Haskell/README\"},{\"text\":\"3. 递归模式和多态\",\"link\":\"/_posts/Haskell/3. 递归模式和多态\"},{\"text\":\"2. 代数数据类型\",\"link\":\"/_posts/Haskell/2. 代数数据类型\"},{\"text\":\"1. Haskell简介\",\"link\":\"/_posts/Haskell/1. Haskell简介\"}],\"collapsed\":true},{\"text\":\"博客\",\"items\":[{\"text\":\"认识一下吧\",\"link\":\"/_posts/博客/Readme\"},{\"text\":\"初尝Web Components\",\"link\":\"/_posts/博客/初尝Web Components\"},{\"text\":\"3字节浮点数\",\"link\":\"/_posts/博客/3字节浮点数\"},{\"text\":\"红黑树\",\"link\":\"/_posts/博客/红黑树\"},{\"text\":\"vue组件和插槽之间的通信\",\"link\":\"/_posts/博客/vue组件和插槽之间的双向通信\"},{\"text\":\"git commit message 规范\",\"link\":\"/_posts/博客/git-commit-message-规范\"},{\"text\":\"nest中使用websocket\",\"link\":\"/_posts/博客/nest中使用websocket\"},{\"text\":\"RMQ\",\"link\":\"/_posts/博客/RMQ\"},{\"text\":\"2023 RoboCom 世界机器人开发者大赛-本科组 (省赛) CAIP 题解\",\"link\":\"/_posts/博客/2023-RoboCom-世界机器人开发者大赛-本科组-省赛-CAIP-题解\"},{\"text\":\"FFT\",\"link\":\"/_posts/博客/FFT\"},{\"text\":\"博客迁移记录\",\"link\":\"/_posts/博客/hexo博客迁移记录\"},{\"text\":\"第十四届蓝桥杯C/C++B组国赛\",\"link\":\"/_posts/博客/第十四届蓝桥杯C-C-B组国赛\"},{\"text\":\"哈密顿路径问题\",\"link\":\"/_posts/博客/哈密顿路径问题\"},{\"text\":\"第十四届蓝桥杯C/C++B组省赛\",\"link\":\"/_posts/博客/第十四届蓝桥杯C-C-B组省赛\"},{\"text\":\"倍增LCA\",\"link\":\"/_posts/博客/倍增LCA\"},{\"text\":\"概率论与数理统计\",\"link\":\"/_posts/博客/概率论与数理统计\"},{\"text\":\"树状数组\",\"link\":\"/_posts/博客/树状数组\"},{\"text\":\"图着色\",\"link\":\"/_posts/博客/图着色\"},{\"text\":\"latex数学公式手册\",\"link\":\"/_posts/博客/latex数学公式手册\"},{\"text\":\"组合数\",\"link\":\"/_posts/博客/组合数\"},{\"text\":\"乘法逆元\",\"link\":\"/_posts/博客/乘法逆元\"},{\"text\":\"欧几里得算法和扩展欧几里得算法\",\"link\":\"/_posts/博客/欧几里得算法和扩展欧几里得算法\"},{\"text\":\"素性检验\",\"link\":\"/_posts/博客/素性检验\"},{\"text\":\"欧拉路径问题\",\"link\":\"/_posts/博客/欧拉路径问题\"},{\"text\":\"矩阵快速幂\",\"link\":\"/_posts/博客/矩阵快速幂\"},{\"text\":\"高精度模板\",\"link\":\"/_posts/博客/高精度模板\"},{\"text\":\"最短路算法\",\"link\":\"/_posts/博客/最短路算法\"},{\"text\":\"排序算法\",\"link\":\"/_posts/博客/排序算法\"},{\"text\":\"线段树\",\"link\":\"/_posts/博客/线段树\"},{\"text\":\"二分查找\",\"link\":\"/_posts/博客/二分查找\"},{\"text\":\"字符串哈希\",\"link\":\"/_posts/博客/字符串哈希\"},{\"text\":\"一文搞定c++自定义排序\",\"link\":\"/_posts/博客/一文搞定cpp自定义排序\"},{\"text\":\"有点学问在的缩进风格\",\"link\":\"/_posts/博客/有点学问的缩进风格\"}],\"collapsed\":true},{\"text\":\"笔记\",\"items\":[{\"text\":\"浏览器原理\",\"items\":[{\"text\":\"渲染进程如何工作\",\"link\":\"/_posts/笔记/浏览器原理/渲染进程如何工作\"},{\"text\":\"浏览器多进程架构\",\"link\":\"/_posts/笔记/浏览器原理/浏览器多进程架构\"}],\"collapsed\":false}],\"collapsed\":true},{\"text\":\"转载|收藏\",\"items\":[{\"text\":\"Lambda Calculus\",\"items\":[{\"text\":\"README\",\"link\":\"/_posts/转载|收藏/Lambda Calculus/README\"},{\"text\":\"2. The Genius of Alonzo Church: Numbers in Lambda Calculus\",\"link\":\"/_posts/转载|收藏/Lambda Calculus/2. The Genius of Alonzo Church: Numbers in Lambda Calculus\"},{\"text\":\"1. My Favorite Calculus: Lambda (part 1)\",\"link\":\"/_posts/转载|收藏/Lambda Calculus/1. My Favorite Calculus: Lambda (part 1)\"}],\"collapsed\":false},{\"text\":\"free-programming-books\",\"link\":\"/_posts/转载|收藏/free-programming-books\"}],\"collapsed\":true}],\"search\":{\"provider\":\"local\"},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/trudbot\"},{\"icon\":\"npm\",\"link\":\"https://www.npmjs.com/org/trudbot\"}],\"returnToTopLabel\":\"返回顶部\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>