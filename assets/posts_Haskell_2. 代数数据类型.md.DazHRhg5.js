import{_ as s,c as i,o as a,a5 as h}from"./chunks/framework.0F8mtAAj.js";const F=JSON.parse('{"title":"2. 代数数据类型","description":"","frontmatter":{"date":"2024-08-02 14:52:59","title":"2. 代数数据类型","lastUpdated":"2024-08-13 19:58:39"},"headers":[],"relativePath":"_posts/Haskell/2. 代数数据类型.md","filePath":"_posts/Haskell/2. 代数数据类型.md","lastUpdated":1723550524000}'),n={name:"_posts/Haskell/2. 代数数据类型.md"},k=h(`<h2 id="枚举类型" tabindex="-1">枚举类型 <a class="header-anchor" href="#枚举类型" aria-label="Permalink to &quot;枚举类型&quot;">​</a></h2><div class="language-haskell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">haskell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Fruit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Apple</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Banana</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Orange</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	deriving</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Show</span></span></code></pre></div><p>以上使用<code>data</code>声明了一个枚举类型， 有<code>Apple</code> 、<code>Banana</code>、<code>Orange</code>三个值。</p><blockquote><p>deriving Show 表示自动为类型生成 show的 type class实例， 以便编译器知道如何打印它</p></blockquote><div class="language-haskell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">haskell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ghci</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Orange</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Orange</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ghci</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fruit1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Fruit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Apple</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ghci</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fruit1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Apple</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ghci</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fruits </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Fruit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Apple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Apple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Orange</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ghci</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fruits</span></span></code></pre></div><p>以上我们可以看到枚举的使用方式。</p><p>枚举可以进行模式匹配:</p><div class="language-haskell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">haskell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ghci</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ghci</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> isMyLove </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Fruit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Bool</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ghci</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> isMyLove </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Banana</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> True</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ghci</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> isMyLove _ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> False</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ghci</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ghci</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> isMyLove </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Apple</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">False</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ghci</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> isMyLove </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Banana</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">True</span></span></code></pre></div><p>以上定义了一个将<code>Fruit</code>枚举转换为bool值的函数， 当传入Banana时返回true， 否则返回false</p><h2 id="代数数据类型" tabindex="-1">代数数据类型 <a class="header-anchor" href="#代数数据类型" aria-label="Permalink to &quot;代数数据类型&quot;">​</a></h2><p>事实上， 枚举只是haskell中代数数据类型的一种使用方式。</p><blockquote><p>代数数据类型 (Algebraic data type, ADT) 指由其他类型的数据组合成的类型。</p><p>积类型: 积类型的值通常由多个值组成， 称为字段。 就如haskell中的元组、c语言中的结构体， 积类型的所有实例都有相同的类型组合， 也就是说都拥有相同数量、类型的字段。</p><p>和类型/联合: 和类型的值会被分为多种类别，称为变体。 每种变体允许有不同的类型定义, 通常由构造函数来实现， 构造函数定义了参数数量、类型。枚举类型是和类型的一个特例，即所有构造函数都没有参数。</p></blockquote><h3 id="超越枚举-haskell中的自定义类型" tabindex="-1">超越枚举--haskell中的自定义类型 <a class="header-anchor" href="#超越枚举-haskell中的自定义类型" aria-label="Permalink to &quot;超越枚举--haskell中的自定义类型&quot;">​</a></h3><p>使用<code>data</code>可以定义和类型, 语法格式如:</p><div class="language-haskell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">haskell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> C1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arg11Type</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">				|</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> C2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arg21Type arg22Type</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">				|</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> C3</span></span></code></pre></div><p>这表示类型T有三种构造函数<code>C1, C2, C3</code>， 构造函数名后紧跟参数的定义。</p><p>以下是一个例子， Person类型有两个构造函数<code>P1</code>、<code>P2</code>， 其中 P1有<code>name</code>和<code>age</code>两个参数， 而<code>P2</code>只有<code>name</code>参数， <code>P3</code>没有任何参数</p><div class="language-haskell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">haskell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- person&#39;s name, age</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> P1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Int</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">						|</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> P2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> String</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">						|</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> P3</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	deriving</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Show</span></span></code></pre></div><blockquote><p>注意， 构造函数名称与它的类型名称是允许相同的， 在不同的场景， haskell会将它解释为不同的函数(构造函数 / 类型)</p><div class="language-haskell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">haskell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Int</span></span></code></pre></div></blockquote><p>使用这些构造函数时， 就像调用一个正常函数一样。</p><div class="language-haskell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">haskell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ghci</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> P1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;张三&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 30</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ghci</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> -- 构造函数必须传入每一个参数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ghci</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> P1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;李四&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ghci</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person2</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">interactive</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">61</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> error</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    •</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> No</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> instance for (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Show</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        arising from a use </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">of</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ‘</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">print</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">’</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        (maybe you haven&#39;t applied a function to enough arguments</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    •</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> In</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a stmt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> an interactive </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GHCi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> command</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> print it</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ghci</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> P2</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;李四&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ghci</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person3</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">P2</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\26446\\22235</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span></code></pre></div><p>自定义类型同样可以使用模式匹配， 它将构造函数的参数值从实例中解构出来</p><div class="language-haskell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">haskell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ::</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> String</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">getName (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">P1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name _)  </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">getName (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">P2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">getName </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">P3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;unkown&quot;</span></span></code></pre></div><h3 id="更高层次上理解模式匹配" tabindex="-1">更高层次上理解模式匹配 <a class="header-anchor" href="#更高层次上理解模式匹配" aria-label="Permalink to &quot;更高层次上理解模式匹配&quot;">​</a></h3><p>在之前的学习中， 我们已经使用了很多数据类型的模式匹配。</p><div class="language-haskell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">haskell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- Int</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">func </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">123</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> true</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- String</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">func </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;abc&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> true</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- list</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">func x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x</span></span></code></pre></div><p>但从根本上来说， 模式匹配只干一件事: 找到传入的参数值是由哪个构造函数构造的， 然后从中解构出值。</p><p>模式匹配的一些规则:</p><ol><li>下划线可以作为通配符， 能匹配任何内容</li><li>使用<code>@</code>你可以在解构的同时， 仍然可以引用整个值</li></ol><div class="language-haskell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">haskell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">showName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ::</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> String</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">showName p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">P1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name _) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;The name field of (&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> show p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;) is &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name</span></span></code></pre></div><ol start="3"><li>模式匹配可以嵌套, 在解构出来的参数基础上可以继续对它进行解构</li></ol><p>模式匹配式的类型定义为</p><div class="language-haskell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">haskell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">pat </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     |</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  var</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     |</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  var </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( pat )</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     |</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ( </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pat1 pat2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> patn )</span></span></code></pre></div><blockquote><p>为了理解<code>func 123 = true</code>这样的值匹配， 你可以把Int类型的定义想象成是这样的一个枚举</p><div class="language-haskell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">haskell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 0 | 1 | -1 | 2 | -2 | ...</span></span></code></pre></div></blockquote><h3 id="递归数据类型" tabindex="-1">递归数据类型 <a class="header-anchor" href="#递归数据类型" aria-label="Permalink to &quot;递归数据类型&quot;">​</a></h3><p>haskell中定义递归数据类型与其他语言类似: 将该类型某个成员的类型定义为该类型即可。</p><p>但递归最重要的就是要有终止条件， 否则将无限递归没有意义。</p><p>对于和类型来说， 只要有一种变体不是递归的， 那就是有终止条件啦!</p><p>下面我们来定义一个链表:</p><div class="language-haskell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">haskell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> LinkList</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Empty</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Node</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> LinkList</span></span></code></pre></div><p>嗯...不错不错， 我们定义了一个LinkList联合类型， 它有两种变体(构造函数)， 其中<code>Empty</code>表示空结点， 而<code>Node</code>表示正常结点， 存储这一个整数， 以及一条链表。</p><p>事实上， haskell内置list的实现与此非常相似， 不过它有专属的语法糖<code>[], :</code></p><h2 id="case表达式" tabindex="-1">case表达式 <a class="header-anchor" href="#case表达式" aria-label="Permalink to &quot;case表达式&quot;">​</a></h2><p><strong>haskell中模式匹配的基本结构是case表达式。</strong></p><div class="language-haskell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">haskell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> exp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">of</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  pat1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> exp1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  pat2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> exp2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  ...</span></span></code></pre></div><p>事实上， haskell定义函数的语法正是case表达式的语法糖。</p><div class="language-haskell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">haskell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 函数语法</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ::</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> String</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">getName (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">P1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name _)  </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">getName (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">P2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">getName </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">P3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;unkown&quot;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 使用case表达式</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ::</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> String</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">getName p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">of</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">P1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name _) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">P2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	P3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;unkown&quot;</span></span></code></pre></div><h2 id="bst" tabindex="-1">BST <a class="header-anchor" href="#bst" aria-label="Permalink to &quot;BST&quot;">​</a></h2><p>好了， 经过上面的学习， 我们学习到了如何自定义类型， 如何在函数中使用自定义类型， 如何定义递归类型， 现在来实现一个简单的搜索树:</p><div class="language-haskell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">haskell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">newtype</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> NodeData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NodeData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Int</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  deriving</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Show</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Eq</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> BST</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Leaf</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Node</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> BST</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> NodeData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> BST</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  deriving</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Show</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Eq</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> CompareResult</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LESS</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> EQUAL</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> GREATER</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  deriving</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Show</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Eq</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">compareNodeData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ::</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> NodeData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> NodeData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> CompareResult</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">compareNodeData (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NodeData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x) (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NodeData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> EQUAL</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LESS</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> GREATER</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 在二叉搜索树中插入一个元素</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">insert</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ::</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> BST</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> NodeData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> BST</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">insert </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Leaf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nodeData </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Node</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Leaf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nodeData </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Leaf</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">insert (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> left nodeDataRoot right) nodeData </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> compareNodeData nodeData nodeDataRoot </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">of</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  EQUAL</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> left nodeData right</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  LESS</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (insert left nodeData) nodeDataRoot right</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  GREATER</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> left nodeDataRoot (insert right nodeData)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 中序遍历</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">inOrder</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ::</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> BST</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NodeData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">inOrder </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Leaf</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> []</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">inOrder (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> left nodeData right) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inOrder left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [nodeData] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inOrder right</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 从列表构建二叉搜索树</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">build</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ::</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NodeData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> BST</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">build </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foldl insert </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Leaf</span></span></code></pre></div><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><p><a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E6%95%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" target="_blank" rel="noreferrer">代数数据类型 - 维基百科，自由的百科全书 (wikipedia.org)</a></p><p><a href="https://en.wikipedia.org/wiki/Product_type" target="_blank" rel="noreferrer">Product type - Wikipedia</a></p>`,53),l=[k];function t(p,e,d,r,g,E){return a(),i("div",null,l)}const o=s(n,[["render",t]]);export{F as __pageData,o as default};
