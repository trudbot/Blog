import{_ as a,c as t,a3 as o,o as n}from"./chunks/framework.C2eWyT4L.js";const h=JSON.parse('{"title":"1. My Favorite Calculus: Lambda (part 1)","description":"","frontmatter":{"title":"1. My Favorite Calculus: Lambda (part 1)","lastUpdated":"2024-08-23 20:23:18","date":"2024-08-20 16:51:02"},"headers":[],"relativePath":"_posts/转载|收藏/Lambda Calculus/1. My Favorite Calculus: Lambda (part 1).md","filePath":"_posts/转载|收藏/Lambda Calculus/1. My Favorite Calculus: Lambda (part 1).md","lastUpdated":1724415864000}'),i={name:"_posts/转载|收藏/Lambda Calculus/1. My Favorite Calculus: Lambda (part 1).md"};function s(l,e,r,u,d,c){return n(),t("div",null,e[0]||(e[0]=[o('<blockquote><p>Repost Notice</p><p>This article is a repost from the original author. All copyrights belong to the original author. I am sharing this article for educational and informational purposes only, and it is not intended for commercial use. If there are any issues regarding copyright infringement, please contact me for removal.</p><p>Original Article Link: <a href="https://goodmath.blogspot.com/2006/05/my-favorite-calculus-lambda-part-1.html" target="_blank" rel="noreferrer">Good Math/Bad Math: My Favorite Calculus: Lambda (part 1)</a></p><p>Disclaimer: The content of this article represents the views of the original author and does not reflect my personal stance. I do not guarantee the accuracy, completeness, or timeliness of the content.</p><p>Thank you to the original author for their hard work and sharing!</p></blockquote><h1 id="my-favorite-calculus-lambda-part-1" tabindex="-1">My Favorite Calculus: Lambda (part 1) <a class="header-anchor" href="#my-favorite-calculus-lambda-part-1" aria-label="Permalink to &quot;My Favorite Calculus: Lambda (part 1)&quot;">​</a></h1><p><em>(In the original version of this post, I tried using a javascript tool for generating MathML. It appears to not work very well; several browsers failed to render it correctly, and it doesn&#39;t work in an RSS feed. I&#39;ve gone back and re-written everything in simple text format.)</em></p><p>In computer science, especially in the field of programming languages, we tend to use one particular calculus a lot: the Lambda calculus. Lambda calculus is also extensively used by logicians studying the nature of computation and the structure of discrete mathematics. Lambda calculus is great for a lot of reasons, among them:</p><ol><li>It&#39;s very simple.</li><li>It&#39;s Turing complete.</li><li>It&#39;s easy to read and write.</li><li>It&#39;s semantics are strong enough that we can do reasoning from it.</li><li>It&#39;s got a good solid model.</li><li>It&#39;s easy to create variants to explore the properties of various alternative ways of structuring computations or semantics.</li></ol><p>The ease of reading and writing lambda calculus is a big deal. It&#39;s led to the development of a lot of extremely good programming languages based, to one degree or another, on the lambda calculus: Lisp, ML, and Haskell are very strongly lambda calculus based.</p><p>The lambda calculus is based on the concept of <em>functions</em>. In the pure lambda calculus, <em>everything</em> is a function; there are no values <em>at all</em> except for functions. But we can build up anything we need using functions. Remember back in the early days of this blog, I talked a bit about how to build mathematics? We can build the entire structure of mathematics from nothing but lambda calculus.</p><p>So, enough lead-in. Let&#39;s dive in a look at LC. Remember that for a calculus, you need to define two things: the syntax, which describes how valid expressions can be written in the calculus; and a set of rules that allow you to symbolically manipulate the expressions.</p><h2 id="lambda-calculus-syntax" tabindex="-1">Lambda Calculus Syntax <a class="header-anchor" href="#lambda-calculus-syntax" aria-label="Permalink to &quot;Lambda Calculus Syntax&quot;">​</a></h2><p>The lambda calculus has exactly three kinds of expressions:</p><ul><li>(1) Function definition: a function in lambda calculus is an expression, written:</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>lambda x . body</span></span></code></pre></div><p>which means &quot;a function with one parameter named X, which returns the result of evaluating the body&quot;. We say that the lambda expression <em>binds</em>the parameter.</p><ul><li><p>(2) Identifier reference: an identifier reference is a name which matches the name of a parameter defined in a function expression enclosing the reference.</p></li><li><p>(3) Function application: applying a function is written by putting the function value in front of its parameter, as in &quot;(lambda x . plus x x) y&quot;.</p></li></ul><h3 id="currying" tabindex="-1">Currying <a class="header-anchor" href="#currying" aria-label="Permalink to &quot;Currying&quot;">​</a></h3><p>There&#39;s a trick that we play in lambda calculus: if you look at the definition above, you&#39;ll notice that a function (lambda expression) only takes one parameter. That seems like a very big constraint - how can you even implement addition with only one parameter?</p><p>It turns out to be no problem, because of the fact that <em>functions are values</em>. So instead of writing a two parameter function, you can write a one parameter function that returns a one parameter function - in the end, it&#39;s effectively the same thing. It&#39;s called currying, after the great logician Haskell Curry.</p><p>For example, suppose we wanted to write a function to add x and y. We&#39;d like to write something like: <code>lambda x y . plus x y</code>. The way we do that with one-parameter functions is: we write one function with one parameter, which returns another function in one parameter. Adding x plus y becomes writing a one-parameter function with parameter x, which returns another one parameter function which adds x to its parameter:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>lambda x.(lambda y. plus x y)</span></span></code></pre></div><p>Now that we know that adding multiple parameter functions doesn&#39;t <em>really</em> add anything but a bit of simplified syntax, we&#39;ll go ahead and use them when it&#39;s convenient.</p><h3 id="free-vs-bound-identifiers" tabindex="-1">Free vs Bound Identifiers <a class="header-anchor" href="#free-vs-bound-identifiers" aria-label="Permalink to &quot;Free vs Bound Identifiers&quot;">​</a></h3><p>One important syntactic issue that I haven&#39;t mentioned yet is <em>closure</em> or <em>complete binding</em>. For a lambda calculus expression to be evaluated, it cannot reference any identifiers that are not <em>bound</em>. An identifier is bound if it a parameter in an enclosing lambda expression; if an identifier is <em>not</em> bound in any enclosing context, then it is called a <em>free</em> variable.</p><ol><li><code>lambda x . plus x y</code>: in this expression, &quot;y&quot; and &quot;plus&quot; are free, because they&#39;re not the parameter of any enclosing lambda expression; x is bound because it&#39;s a parameter of the function definition enclosing the expression &quot;plus x y&quot; where it&#39;s referenced.</li><li><code>lambda x y.y x</code>: in this expression both x and y are bound, because they are parameters of the function definition.</li><li><code>lambda y . (lambda x . plus x y)</code>: In the inner lambda, &quot;<code>lambda x . plus x y</code>&quot;, y and plus are free and x is bound. In the full expression, both x and y are bound: x is bound by the inner lambda, and y is bound by the other lambda. &quot;plus&quot; is still free.</li></ol><p>We&#39;ll often use &quot;free(x)&quot; to mean the set of identifiers that are free in the expression &quot;x&quot;.</p><p>A lambda calculus expression is completely valid only when all of its variables are bound. But when we look at smaller subexpressions of a complex expression, taken out of context, they can have free variables - and making sure that the variables that are free in subexpressions are treated right is very important.</p><h2 id="lambda-calculus-evaluation-rules" tabindex="-1">Lambda Calculus Evaluation Rules <a class="header-anchor" href="#lambda-calculus-evaluation-rules" aria-label="Permalink to &quot;Lambda Calculus Evaluation Rules&quot;">​</a></h2><p>There are only two real rules in lambda calculus; they&#39;re called alpha and beta. Alpha is also called &quot;conversion&quot;, and beta is also called &quot;reduction&quot;.</p><h3 id="alpha-conversion" tabindex="-1">Alpha Conversion <a class="header-anchor" href="#alpha-conversion" aria-label="Permalink to &quot;Alpha Conversion&quot;">​</a></h3><p>alpha is a renaming operation; basically it says that the names of variables are unimportant: given any expression in lambda calculus, we can change the name of the parameter to a function as long as we change all free references to it inside the body.</p><p>So - for instance, if we had an expression like:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>lambda x . if (= x 0) then 1 else x^2</span></span></code></pre></div><p>We can do alpha changing X to Y (written &quot;alpha[x/y]&quot; and get):</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>lambda y . if (= y 0) then 1 else y^2</span></span></code></pre></div><p>Doing alpha does <em>not</em> change the meaning of the expression in any way. But as we&#39;ll see later, it&#39;s important because it gives us a way of doing things like recursion.</p><h3 id="beta-reduction" tabindex="-1">Beta Reduction <a class="header-anchor" href="#beta-reduction" aria-label="Permalink to &quot;Beta Reduction&quot;">​</a></h3><p>Beta reduction is where things get interesting: this single rule is all that&#39;s needed to make the lambda calculus capable of performing <em>any</em> computation that can be done by a machine.</p><p>Beta basically says that if you have a function application, you can replace it with a copy of the body of the function with references to the parameter identifiers replaced by references to the parameter value in the application. That sounds confusing, but it&#39;s actually pretty easy when you see it in action.</p><p>Suppose we have the application expression: &quot;<code>(lambda x . x + 1) 3</code>&quot;. What beta says is that we can replace the application by taking the body of the function (which is &quot;x + 1&quot;); and replacing references to the parameter &quot;x&quot; by the value &quot;3&quot;; so the result of the beta reduction is &quot;3 + 1&quot;.</p><p>A slightly more complicated example is the expression: <code>lambda y . (lambda x . x + y)) q</code> It&#39;s an interesting expression, because it&#39;s a lambda expression that when applied, results in another lambda expression: that is, it&#39;s a function that creates functions. When we do beta reduction in this, we&#39;re replacing all references to the parameter &quot;y&quot; with the identifier &quot;q&quot;; so, the result is &quot;<code>lambda x. x+q</code>&quot;.</p><p>One more example, just for the sake of being annoying: &quot;<code>(lambda x y. x y) (lambda z . z * z) 3</code>&quot;. That&#39;s a function that takes two parameters, and applies the first one to the second one. When we evaluate that, we replace the parameter &quot;x&quot; in the body of the first function with &quot;<code>lambda z . z * z</code>&quot;; and we replace the parameter &quot;y&quot; with &quot;3&quot;, getting: &quot;<code>(lambda z . z * z) 3</code>&quot;. And we can perform beta on that, getting &quot;3 * 3&quot;.</p><p>Written formally, beta says:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>lambda x . B e = B[x := e] if free(e) subset free(B[x := e]</span></span></code></pre></div><p>That condition on the end, &quot;if free(e) subset free(B[x := e]&quot; is why we need alpha: we can only do beta reduction <em>if</em> doing it doesn&#39;t create any collisions between bound identifiers and free identifiers: if the identifier &quot;z&quot; is free in &quot;e&quot;, then we need to be sure that the beta-reduction doesn&#39;t make &quot;z&quot; become bound. If there is a name collision between a variable that is bound in &quot;B&quot; and a variable that is free in &quot;e&quot;, then we need to use alpha to change the identifier names so that they&#39;re different.</p><p>As usual, an example will make that clearer: Suppose we have a expression defining a function, &quot;<code>lambda z . lambda x . x+z)</code>&quot;. Now, suppose we want to apply it:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(lambda z . (lambda x . x + z)) (x + 2)</span></span></code></pre></div><p>In the parameter &quot;(x + 2)&quot;, x is free. Now, suppose we break the rule and go ahead and do beta. We&#39;d get: <code>lambda x . x + x + 2</code></p><p>The variable that was <em>free</em> in &quot;x + 2&quot; is now bound. Now suppose we apply that function: <code>(lambda x . x + x + 2) 3</code></p><p>By beta, we&#39;d get &quot;3 + 3 + 2&quot;.</p><p>What if we did alpha the way we were supposed to?</p><p>by alpha[x/y]: <code>(lambda z . (lambda y . y+z)) (x + 2)</code> by beta: <code>(lambda y . y + x + 2) 3</code> by beta again: <code>3 + x + 2</code>.</p><p>&quot;3+x+2&quot; and &quot;3+3+2&quot; are very different results!</p><p>And that&#39;s pretty much it. There&#39;s another rule you can <em>optionally</em> add called Eta-reduction, but we&#39;ll skip that for now. What I&#39;ve described here is Turing complete - a full effective computation system. To make it useful, and see how this can be used to do real stuff, we need to define a bunch of basic functions that allow us to do math, condition tests, recursion, etc. I&#39;ll talk about those in my next post.</p><p>We also haven&#39;t defined a model for lambda-calculus yet. (I discussed models <a href="http://goodmath.blogspot.com/2006/04/more-logic-models-and-why-they-matter.html" target="_blank" rel="noreferrer">here</a> and <a href="http://goodmath.blogspot.com/2006/04/correcting-my-models-post-or-why.html" target="_blank" rel="noreferrer">here</a>.) That&#39;s actually quite an important thing! LC was played with by logicians for several years before they were able to come up with a complete model for it, and it was a matter of great concern that although LC looked correct, the early attempts to define a model for it were failures. After all, remember that if there isn&#39;t a valid model, that means that the results of the system are meaningless!</p>',53)]))}const m=a(i,[["render",s]]);export{h as __pageData,m as default};
