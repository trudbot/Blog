import{_ as i,c as a,a3 as e,o as t}from"./chunks/framework.D_seZniL.js";const d=JSON.parse('{"title":"nest中使用websocket","description":"","frontmatter":{"title":"nest中使用websocket","mathjax":true,"tags":["websocket","nest"],"categories":["后端","nest"],"abbrlink":52255,"date":"2023-09-08 04:20:21","lastUpdated":"2024-08-23 20:23:18"},"headers":[],"relativePath":"_posts/博客/nest中使用websocket.md","filePath":"_posts/博客/nest中使用websocket.md","lastUpdated":1724415864000}'),n={name:"_posts/博客/nest中使用websocket.md"};function p(h,s,l,k,r,o){return t(),a("div",null,s[0]||(s[0]=[e(`<p>本文主要总结nest中如何使用socket.io等WebSocket库， socket.io的使用可见<a href="https://socket.io/zh-CN/" target="_blank" rel="noreferrer">socket.io</a></p><h2 id="网关注解" tabindex="-1">网关注解 <a class="header-anchor" href="#网关注解" aria-label="Permalink to &quot;网关注解&quot;">​</a></h2><p>要在nest中写websocket相关的代码， 需要创建一个被<code>@WebSocketGateway()</code>装饰的类， 里面封装了websocket服务基本的API。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">WebSocketGateway</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({})</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ChatGetWay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span></code></pre></div><p>在类中有三个固定名称的钩子函数， 控制着websocket的生命周期:</p><ol><li>afterInit(), 参数为服务器实例</li><li>handleConnection()， 参数为客户端实例</li><li>handleDisconnect()， 参数为客户端实例</li></ol><p>作用顾名思义。</p><h2 id="socket-io配置" tabindex="-1">Socket.io配置 <a class="header-anchor" href="#socket-io配置" aria-label="Permalink to &quot;Socket.io配置&quot;">​</a></h2><p>在使用socket.io创建服务器时， 往往需要进行相关配置如跨域等</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// server-side</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> io</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Server</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(httpServer, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  cors: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    origin: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://example.com&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    allowedHeaders: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;my-custom-header&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    credentials: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>在nest中， 只需要将配置对象传入注解即可。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">WebSocketGateway</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cors: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        origin: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;*&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        methods: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;GET&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;POST&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    namespace: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;chat&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>在网关的第一个参数可以设置websocket的端口</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">WebSocketGateway</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">80</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, { namespace: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;events&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span></code></pre></div><p>当然， 如果你不传入此参数， websocket服务器会自动挂载到nest启动的http服务器上， 监听相同的端口。</p><h2 id="socket-io业务" tabindex="-1">Socket.io业务 <a class="header-anchor" href="#socket-io业务" aria-label="Permalink to &quot;Socket.io业务&quot;">​</a></h2><p>socket.io中最重要的就是发送和接收事件消息了。 在nest中， 需要使用<code>@SubscribeMessage()</code>注解来装饰一个函数， 使其成为事件处理函数。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SubscribeMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;message&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 订阅\`message\`事件</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">handleMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  @</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ConnectedSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() client, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 发送消息的客户端引用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  @</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MessageBody</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() data </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 事件携带的信息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // do something</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>上面使用了两个注解来修饰事件处理函数的参数， 这是因为websocket网关是跨平台的， 平台不同， 客户端实例和消息格式也都可能不同。</p><h3 id="socket-io服务器实例" tabindex="-1">socket.io服务器实例 <a class="header-anchor" href="#socket-io服务器实例" aria-label="Permalink to &quot;socket.io服务器实例&quot;">​</a></h3><p>要在nest中使用socket.io发送消息， 需要直接访问到服务器实例。</p><p>使用<code>@WebSocketServer()</code>注解修饰成员变量， 即可获得服务器实例。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">WebSocketServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">server</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Server;</span></span></code></pre></div><p>更多的与平台API相关的操作都可以通过服务器实例来完成。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.server.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(group).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">emit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;message&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, msg);</span></span></code></pre></div><h2 id="使用websocket服务" tabindex="-1">使用WebSocket服务 <a class="header-anchor" href="#使用websocket服务" aria-label="Permalink to &quot;使用WebSocket服务&quot;">​</a></h2><p>WebSocket网关类是特殊的Provider，也就是类似于被<code>@Injectable()</code> 的类， 使用上是类似的。可以通过构造函数注入其它Service、被模块管理， 也可以被注入。</p><h2 id="websocket和http同端口时的跨域问题" tabindex="-1">websocket和http同端口时的跨域问题 <a class="header-anchor" href="#websocket和http同端口时的跨域问题" aria-label="Permalink to &quot;websocket和http同端口时的跨域问题&quot;">​</a></h2><p>如果你的后端中http和websocket是使用的同一端口， 即时你nest实例和websocket网关都配置了跨域， 你在使用客户端的时候还是会发生跨域。</p><p>这是以为socket.io客户端进行连接时， 首先会尝试建立HTTP长轮询连接， 连接成功后才会尝试建立WebSocket连接。</p><p>而同一端口已经存在了处理HTTP的服务器, 因此客户端尝试建立HTTP长轮询时， 就会发生错误。</p><p>解决办法是， 在客户端创建连接时配置， 只允许建立WebSocket连接。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> connection</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> io</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(url, {transports: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;websocket&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] });</span></span></code></pre></div><p>或者， 给socket.io服务器一个单独的端口。</p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><p><a href="https://docs.nestjs.cn/10/websockets" target="_blank" rel="noreferrer">WEBSOCKETS (nestjs.cn)</a></p><p><a href="https://socket.io/zh-CN/docs/v4/" target="_blank" rel="noreferrer">介绍 | Socket.IO</a></p><p><a href="https://socket.io/zh-CN/docs/v4/client-options/#transports" target="_blank" rel="noreferrer">客户端配置 | Socket.IO</a></p>`,38)]))}const E=i(n,[["render",p]]);export{d as __pageData,E as default};
