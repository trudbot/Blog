import{_ as i,c as a,a3 as t,o as h}from"./chunks/framework.D_seZniL.js";const g=JSON.parse('{"title":"3. 递归模式和多态","description":"","frontmatter":{"title":"3. 递归模式和多态","lastUpdated":"2024-08-23 20:23:18","date":"2024-08-15 14:14:07"},"headers":[],"relativePath":"_posts/Haskell/3. 递归模式和多态.md","filePath":"_posts/Haskell/3. 递归模式和多态.md","lastUpdated":1724415864000}'),l={name:"_posts/Haskell/3. 递归模式和多态.md"};function n(e,s,k,p,r,d){return h(),a("div",null,s[0]||(s[0]=[t(`<h2 id="递归模式" tabindex="-1">递归模式 <a class="header-anchor" href="#递归模式" aria-label="Permalink to &quot;递归模式&quot;">​</a></h2><blockquote><p>Functional languages excel at wholemeal programming, a term coined by Geraint Jones. Wholemeal programming means to think big: work with an entire list, rather than a sequence of elements; develop a solution space, rather than an individual solution; imagine a graph, rather than a single path. The wholemeal approach often offers new insights or provides new perspectives on a given problem. It is nicely complemented by the idea of projective programming: first solve a more general problem, then extract the interesting bits and pieces by transforming the general program into more specialised ones.</p></blockquote><p>全麦编程/整体编程 强调要从整体上看问题。</p><p>在haskell这样一门函数式编程语言中， 递归是非常常用和重要的操作。</p><p>而大部分都递归操作其实是存在一些共性的， 尤其是对于列表:</p><ul><li>对列表每个元素进行一些操作， 得到新列表</li><li>去除不满足条件的一些元素</li><li>由列表计算值</li><li>生成一个列表</li></ul><p>如去除不满足条件的一些元素， 本质上是对列表进行一次遍历， 并对每个元素应用一段逻辑来决定是否要去除， 最后得到新的一个列表。</p><p>具体的判断逻辑我们并不在意， 重要的是递归遍历 + 逻辑判断这个相同的&quot;递归逻辑&quot;， 我们叫他递归模式。</p><p>根据我们学过的知识， 很容易就能写出这样的代码:</p><div class="language-haskell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">haskell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filterIntList</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ::</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">filterIntList f </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> []</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">filterIntList f (x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">xs)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> f x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> filterIntList f xs</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> otherwise </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> filterIntList f xs</span></span></code></pre></div><p>封装/抽取递归模式， 使得我们只需要编写具体的业务逻辑即可， 屏蔽了大量没必要的关注点。</p><h2 id="泛型" tabindex="-1">泛型 <a class="header-anchor" href="#泛型" aria-label="Permalink to &quot;泛型&quot;">​</a></h2><div class="language-haskell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">haskell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filterIntList</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ::</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">filterIntList f </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> []</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">filterIntList f (x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">xs)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> f x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> filterIntList f xs</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> otherwise </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> filterIntList f xs</span></span></code></pre></div><p>这个函数还不错， 但它只能用在<code>[Int]</code>类型上。</p><p>如果要进一步提升它的抽象程度， 就需要使用泛型， 让它能适配于任何类型的列表。</p><h3 id="类型上的泛型" tabindex="-1">类型上的泛型 <a class="header-anchor" href="#类型上的泛型" aria-label="Permalink to &quot;类型上的泛型&quot;">​</a></h3><p>在自定义类型上使用泛型， 只需要将泛型符号加到类型名后即可。</p><p>如一个列表类型:</p><div class="language-haskell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">haskell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> EMPTY</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> CONS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e)</span></span></code></pre></div><ul><li><code>EMPTY</code>， 空参构造函数， 表示列表的结束</li><li><code>CONS</code>, 列表的结点 <ul><li><code>e</code>: 结点存储的数据</li><li><code>(LIST e)</code>: 下一个结点</li></ul></li></ul><p>其中<code>e</code>叫做<em>类型变量</em>， 它代表了一个不确定的类型， 需要由使用时指定或推断。</p><p>使用具有泛型的类型也很简单, 就像为一个函数传参一样:</p><div class="language-haskell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">haskell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lst1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ::</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> List</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Int</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lst1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> CONS</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CONS</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> EMPTY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><blockquote><p>请注意， 类型变量必须以小写字母开头， 而类型以大写字母开头</p></blockquote><h2 id="函数上的泛型" tabindex="-1">函数上的泛型 <a class="header-anchor" href="#函数上的泛型" aria-label="Permalink to &quot;函数上的泛型&quot;">​</a></h2><p>很简单 ，直接在函数类型定义上使用类型变量即可。</p><div class="language-haskell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">haskell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">myFilter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ::</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (e </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [e] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [e]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">myFilter f </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> []</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">myFilter f (x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xs)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> f x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myFilter f xs</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> otherwise </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myFilter f xs</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">main </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> do</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  print (myFilter (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span></code></pre></div><h2 id="prelude" tabindex="-1">Prelude <a class="header-anchor" href="#prelude" aria-label="Permalink to &quot;Prelude&quot;">​</a></h2><p><a href="https://hackage.haskell.org/package/base-4.20.0.1/docs/Prelude.html" target="_blank" rel="noreferrer">Prelude</a>是haskell的标准库， 它是默认导入， 因此不需要进行任何导入即可使用它。</p><p>prelude中有非常非常多的实用函数！像<code>map</code>、<code>filter</code>、<code>foldl</code>等等。</p>`,30)]))}const o=i(l,[["render",n]]);export{g as __pageData,o as default};
