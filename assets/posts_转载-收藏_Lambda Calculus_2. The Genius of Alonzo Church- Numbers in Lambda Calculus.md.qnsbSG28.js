import{_ as a,c as s,a3 as t,o}from"./chunks/framework.CXF8Minp.js";const p=JSON.parse('{"title":"2. The Genius of Alonzo Church: Numbers in Lambda Calculus","description":"","frontmatter":{"title":"2. The Genius of Alonzo Church: Numbers in Lambda Calculus","lastUpdated":"2024-09-15 08:07:04","date":"2024-08-20 18:15:51"},"headers":[],"relativePath":"_posts/转载-收藏/Lambda Calculus/2. The Genius of Alonzo Church- Numbers in Lambda Calculus.md","filePath":"_posts/转载-收藏/Lambda Calculus/2. The Genius of Alonzo Church- Numbers in Lambda Calculus.md","lastUpdated":1726387691000}'),n={name:"_posts/转载-收藏/Lambda Calculus/2. The Genius of Alonzo Church- Numbers in Lambda Calculus.md"};function i(u,e,l,r,c,d){return o(),s("div",null,e[0]||(e[0]=[t('<blockquote><p>Repost Notice</p><p>This article is a repost from the original author. All copyrights belong to the original author. I am sharing this article for educational and informational purposes only, and it is not intended for commercial use. If there are any issues regarding copyright infringement, please contact me for removal.</p><p>Original Article Link: <a href="https://goodmath.blogspot.com/2006/05/genius-of-alonzo-church-numbers-in.html" target="_blank" rel="noreferrer">Good Math/Bad Math: The Genius of Alonzo Church: Numbers in Lambda Calculus</a></p><p>Disclaimer: The content of this article represents the views of the original author and does not reflect my personal stance. I do not guarantee the accuracy, completeness, or timeliness of the content.</p><p>Thank you to the original author for their hard work and sharing!</p></blockquote><h1 id="the-genius-of-alonzo-church-numbers-in-lambda-calculus" tabindex="-1">The Genius of Alonzo Church: Numbers in Lambda Calculus <a class="header-anchor" href="#the-genius-of-alonzo-church-numbers-in-lambda-calculus" aria-label="Permalink to &quot;The Genius of Alonzo Church: Numbers in Lambda Calculus&quot;">​</a></h1><p>So, now, time to move on to doing interesting stuff with lambda calculus. To start with, for convenience, I&#39;ll introduce a bit of syntactic sugar to let us name functions. This will make things easier to read as we get to complicated stuff.</p><p>To introduce a &quot;global&quot; function (that is a function that we&#39;ll use throughout our lambda calculus introduction without including its declaration in every expression), we&#39;ll use a &quot;let&quot; expression:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>let square = lambda x . x^2</span></span></code></pre></div><p>This declares a function named &quot;square&quot;, whose definition is <code>lambda x . x^2</code>. If we had an expression &quot;square 4&quot;, the &quot;let&quot; above means that it would effectively be treated as if the expression were:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(lambda square . square 4)(lambda x . x^2)</span></span></code></pre></div><p>In some of the examples, I used numbers and arithmetic operations. But numbers don&#39;t really exist in lambda calculus; all we really have are functions! So we need to invent some way of <em>creating</em> numbers using functions. Fortunately, Alonzo Church, the genius who invented the lambda calculus worked out how to do that. His version of numbers-as-functions are called <em>Church Numerals</em>.</p><p>In Church numerals, all numbers are functions with two parameters:</p><ol><li>Zero is &quot;<code>lambda s z . z</code>&quot;.</li><li>One is &quot;<code>lambda s z . s z</code>&quot;.</li><li>Two is &quot;<code>lambda s z . s (s z)</code>&quot;.</li><li>For any number &quot;n&quot;, it&#39;s Church numeral is a function which applies its first parameter to its second parameter &quot;n&quot; times.</li></ol><p>A good way of understanding this is to think of &quot;z&quot; as being a a name for a zero-value, and &quot;s&quot;as a name for a successor function. So zero is a function which just returns the &quot;0&quot; value; one is a function which applies the successor function once to zero; two is a function which applies successor to the successor of zero, etc.</p><p>Now - watch this; if we want to do addition, x + y, we need to write a function with four parameters; the two numbers to add; and the &quot;s&quot; and &quot;z&quot; values we want in the resulting number:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>let add = lambda s z x y . x s (y s z)</span></span></code></pre></div><p>Let&#39;s curry that, to separate the two things that are going on. First, it&#39;s taking two parameters which are the two values we need to add; second, it needs to normalize things so that the two values being added end up sharing the same binding of the zero and successor values.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>let add = lambda x y. (lambda s z . (x s (y s z)))</span></span></code></pre></div><p>Look at that for a moment; what that says is, to add x and y: create the church numeral &quot;y&quot; using the parameters &quot;s&quot; and &quot;z&quot;. Then <em>apply x</em> to the church numeral y, using the new church numeral &quot;y&quot; defined in &quot;s&quot; and &quot;z&quot;. That is: a number is a function <em>which adds itself to another number</em>.</p><p>Let&#39;s look a tad closer, and run through the evaluation of 2 + 3:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>add (lambda s z . s (s z)) (lambda s z . s (s (s z))) news newz</span></span></code></pre></div><p>To make things easier, let&#39;s alpha 2 and 3, so that &quot;2&quot; uses &quot;s2&quot; and &quot;z2&quot;, and 3 uses &quot;s3&quot; and &quot;z3&quot;;</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>add (lambda s2 z2 . s2 (s2 z2)) (lambda s3 z3 . s3 (s3 (s3 z3)))</span></span></code></pre></div><p>Now, let&#39;s do replace &quot;add&quot; with its definition:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(lambda x y .(lambda s z. (x s y s z))) (lambda s2 z2 . s2 (s2 z2)) (lambda s3 z3 . s3 (s3 (s3 z3)))</span></span></code></pre></div><p>Now, let&#39;s do a beta on add:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>lambda s z . (lambda s2 z2 . s2 (s2 z2)) s (lambda s3 z3 . s3 (s3 (s3 z3)) s z)</span></span></code></pre></div><p>And now let&#39;s beta the church numberal for three. This basically just &quot;normalizes&quot; three: it replaces the successor and zero function in the definition of three with the successor and zero functions from the parameters to add.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>lambda s z . (lambda s2 z2 . s2 (s2 z2)) s (s (s (s z)))</span></span></code></pre></div><p>Now.. Here comes the really neat part. Beta again, this time on the lambda for two. Look at what we&#39;re going to be doing here: two is a function which takes two parameters: a successor function, and zero function. To add two and three, we&#39;re using the successor function from add function; and we&#39;re using the result of evaluating three <em>as the value of the zero!</em>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>lambda s z . s (s (s (s (s z))))</span></span></code></pre></div><p>And we have our result: the church numeral for five!</p>',29)]))}const m=a(n,[["render",i]]);export{p as __pageData,m as default};
