import{_ as e,c as t,o as a,a4 as r}from"./chunks/framework.7ZqS4VQN.js";const u=JSON.parse('{"title":"渲染进程如何工作","description":"","frontmatter":{"title":"渲染进程如何工作","lastUpdated":"2024-07-08 20:54:17","date":"2024-07-08 15:38:34"},"headers":[],"relativePath":"_posts/笔记/浏览器原理/渲染进程如何工作.md","filePath":"_posts/笔记/浏览器原理/渲染进程如何工作.md","lastUpdated":1720443325000}'),o={name:"_posts/笔记/浏览器原理/渲染进程如何工作.md"},s=r('<p>渲染进程是浏览器最重要的进程， 本文将是对<a href="https://developer.chrome.com/blog/inside-browser-part3?hl=en" target="_blank" rel="noreferrer">Inside look at modern web browser (part 3) | Blog | Chrome for Developers</a>的重复。</p><h2 id="_1-html文件解析" tabindex="-1">1. html文件解析 <a class="header-anchor" href="#_1-html文件解析" aria-label="Permalink to &quot;1. html文件解析&quot;">​</a></h2><p>渲染进程收到.html文件时， 会开始html内容解析为DOM(Document Object Model)。</p><p>DOM是浏览器对网页的抽象， 是web程序员通过javascript对网页操作的一套数据结构和api。</p><h3 id="_1-1-资源加载" tabindex="-1">1. 1 资源加载 <a class="header-anchor" href="#_1-1-资源加载" aria-label="Permalink to &quot;1. 1 资源加载&quot;">​</a></h3><p>html可能会引用外部的图片、css、js等资源(通过link、img、script等等标签引用)， 这些资源需要网络线程去进行网络请求， 在html解析的过程中会找到他们将任务发送到网络线程。</p><p><strong>javascript</strong>的请求可能会阻塞解析:</p><p>浏览器遇到script标签时， 会停止解析， 在 加载 -&gt; 解释 -&gt; 执行 后才会继续。</p><p>阻塞解析的原因是， 引用的javascript代码可能会执行<code>document.write</code>等api更改了<strong>整个dom结构</strong>， 从而更改了document的形状; 从<a href="https://html.spec.whatwg.org/multipage/parsing.html#overview-of-the-parsing-model" target="_blank" rel="noreferrer">HTML Standard (whatwg.org)</a>中可以看出， js增加了新的html片段后， 需要重新tokenizer</p><p><img src="https://trudbot-md-img.oss-cn-shanghai.aliyuncs.com/202407081618580.png" alt="截屏2024-07-08 下午4.18.35"></p><p>当你的javascript中没有使用<code>document.wire()</code>时, 可以向 <code>&lt;script&gt;</code> 标记添加 <a href="https://developer.mozilla.org/docs/Web/HTML/Element/script#attr-async" target="_blank" rel="noreferrer"><code>async</code></a> 或 <a href="https://developer.mozilla.org/docs/Web/HTML/Element/script#attr-defer" target="_blank" rel="noreferrer"><code>defer</code></a> 属性或使用<code>es modules</code>。然后，浏览器会异步加载并运行 JavaScript 代码，而不会阻止解析。</p><blockquote><p>async和defer区别?</p><ul><li>defer告诉浏览器不需要阻塞解析加载运行此脚本， 而是在文档解析完毕， 但在<code>DOMContentLoaded</code>钩子之前执行。 <ul><li>包含 <code>defer</code> 属性的脚本将阻塞 <code>DOMContentLoaded</code> 事件触发，直到脚本完成加载并执行。</li><li>包含 <code>defer</code> 属性的脚本会按照它们出现在文档中的顺序执行。</li><li>esm模块无需使用defer， 它们默认就是defer</li></ul></li><li>async也可以解除浏览器对解析的阻塞，async 脚本会被并行请求，并尽快解析和执行。</li></ul><p>总之async和defer都可以解除阻塞， 但执行策略和时机不同。</p></blockquote><h2 id="_2-样式计算" tabindex="-1">2. 样式计算 <a class="header-anchor" href="#_2-样式计算" aria-label="Permalink to &quot;2. 样式计算&quot;">​</a></h2><p><img src="https://trudbot-md-img.oss-cn-shanghai.aliyuncs.com/202407081635461.png" alt="计算样式"></p><p>此过程会使用文档中或引用的所有css, 以及dom结点的<a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/html/resources/html.css" target="_blank" rel="noreferrer">默认样式</a>， 计算得到每一个结点的样式表。 即浏览器开发者工具css中computed的内容。</p><h2 id="_3-布局-layout" tabindex="-1">3. 布局(layout) <a class="header-anchor" href="#_3-布局-layout" aria-label="Permalink to &quot;3. 布局(layout)&quot;">​</a></h2><p><img src="https://trudbot-md-img.oss-cn-shanghai.aliyuncs.com/202407081640405.png" alt="layout"></p><blockquote><p>主线程会遍历 DOM 和计算出的样式，并创建布局树，其中包含 x y 坐标和边界框大小等信息。布局树的结构可能与 DOM 树类似，但它仅包含与页面上可见内容相关的信息。如果应用了 <code>display: none</code>，则该元素不属于布局树（然而，具有 <code>visibility: hidden</code> 的元素在布局树中）。同样，如果应用包含类似 <code>p::before{content:&quot;Hi!&quot;}</code> 的伪元素，它就会包含在布局树中，即使它不在 DOM 中也是如此。</p><p>确定网页的布局是一项具有挑战性的任务。即使是最简单的页面布局（例如从上到下的块流），也必须考虑字体大小和换行位置，因为它们会影响段落的大小和形状；而后又会影响下一段落的位置。</p><p>CSS 可以使元素悬浮到一侧、遮盖溢出内容以及更改书写方向。可以想象，这个布局阶段有一项繁重的任务。在 Chrome 中，有整个工程师团队负责开发布局。如果您想详细了解他们的工作，可以观看 <a href="https://www.youtube.com/watch?v=Y5Xa4H2wtVA&amp;hl=zh-cn" target="_blank" rel="noreferrer">BlinkOn Conference 的一些演讲</a>，并且非常有意思。</p></blockquote><p><s>讲的太好了， 原样搬来</s></p><p>layout的过程计算得到了dom元素被绘制在屏幕上所需的信息, 如位置、颜色、大小等等。</p><h2 id="_4-绘制-paint" tabindex="-1">4. 绘制(paint) <a class="header-anchor" href="#_4-绘制-paint" aria-label="Permalink to &quot;4. 绘制(paint)&quot;">​</a></h2><p>拥有 DOM、样式和布局仍然不足以渲染页面。假设您正尝试复制一幅画。您已经知道元素的大小、形状和位置，但仍需判断它们的绘制顺序。</p><p><img src="https://trudbot-md-img.oss-cn-shanghai.aliyuncs.com/202407081702348.png" alt="Z-index 未通过"></p><p>在paint流程中， 会生成具体的一个绘制流程, 就像<code>先画背景， 然后是文本， 然后是矩形</code>一样。</p><h2 id="_5-draw-合成-compositing" tabindex="-1">5. draw / 合成(compositing) <a class="header-anchor" href="#_5-draw-合成-compositing" aria-label="Permalink to &quot;5. draw / 合成(compositing)&quot;">​</a></h2><p>现在渲染进程得到了文档结构、每个元素样式、几何图形信息以及绘制顺序， 是时候把它真正的显示在屏幕上了。</p><p>众所周知, 浏览器页面靠<strong>帧</strong>的不断更新(60/s)， draw的过程就是控制帧如何生成。</p><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><p>以下结尾照搬</p></div><h3 id="什么是合成" tabindex="-1">什么是合成 <a class="header-anchor" href="#什么是合成" aria-label="Permalink to &quot;什么是合成&quot;">​</a></h3><p>合成是一种技术，可将网页的各个部分分离成图层，分别将它们光栅化，然后在单独的线程（称为“合成器线程”）中合成为网页。如果发生滚动，由于图层已光栅化，因此只需合成新帧即可。同样，可以通过移动层和合成新帧来实现动画效果。</p><p>您可以在开发者工具中使用<a href="https://blog.logrocket.com/eliminate-content-repaints-with-the-new-layers-panel-in-chrome-e2c306d4d752?gi=cd6271834cea" target="_blank" rel="noreferrer">“Layers”面板</a>查看网站是如何划分为多个图层的。</p><h3 id="划分为层" tabindex="-1">划分为层 <a class="header-anchor" href="#划分为层" aria-label="Permalink to &quot;划分为层&quot;">​</a></h3><p>为了确定哪些元素需要位于哪些层，主线程会遍历布局树来创建层树（此部分在开发者工具性能面板中称为“Update Layer Tree”）。如果网页中本应属于单独图层的某些部分（例如滑入式侧边菜单）没有出现，您可以使用 CSS 中的 <code>will-change</code> 属性来提示浏览器。</p><p><img src="https://trudbot-md-img.oss-cn-shanghai.aliyuncs.com/202407082022043.png" alt="image-20240708202247934">图 16：遍历布局树生成层树的主线程</p><p>您可能很想为每个元素都添加层，但与每帧将页面的一小部分光栅化相比，跨过多层进行合成可能会导致操作速度缓慢，因此请务必衡量应用的渲染性能。如需详细了解此主题，请参阅<a href="https://developers.google.com/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count?hl=zh-cn" target="_blank" rel="noreferrer">坚持仅合成器的属性和管理层计数</a>。</p><h3 id="主线程外的光栅和合成" tabindex="-1">主线程外的光栅和合成 <a class="header-anchor" href="#主线程外的光栅和合成" aria-label="Permalink to &quot;主线程外的光栅和合成&quot;">​</a></h3><p>创建层树并确定绘制顺序后，主线程会将该信息提交到合成器线程。然后，合成器线程会光栅化每个图层。图层的大小可能相当于页面的全部长度，因此合成器线程会将它们分成多块图块，并将每个图块发送到光栅线程。光栅线程会光栅化每个图块并将它们存储在 GPU 内存中。</p><p><img src="https://trudbot-md-img.oss-cn-shanghai.aliyuncs.com/202407082023618.png" alt="image-20240708202238177">图 17：创建图块位图并发送到 GPU 的光栅线程</p><p>合成器线程可以优先处理不同的光栅线程，以便先对视口内（或附近）的内容进行光栅化。图层还具有多个针对不同分辨率的平铺处理，以处理放大操作等操作。</p><p>图块光栅化后，合成器线程会收集图块信息（称为“绘制四边形”）来创建<strong>合成器框架</strong>。</p><table tabindex="0"><thead><tr><th>绘制四边形</th><th>包含功能块在内存中的位置，以及要在页面中的什么位置绘制功能块（考虑页面合成）等信息。</th></tr></thead><tbody><tr><td>合成器框架</td><td>表示页面帧的绘制四边形集合。</td></tr></tbody></table><p>然后，通过 IPC 将合成器帧提交到浏览器进程。此时，可以从界面线程（针对浏览器界面更改）或针对扩展程序的其他渲染程序进程添加另一个合成器帧。系统会将这些合成器帧发送到 GPU，以便在屏幕上显示。如果发生滚动事件，合成器线程会再创建一个合成器帧以发送到 GPU。</p><p>![image-20240708202220850](/Users/songyiping03/Library/Application Support/typora-user-images/image-20240708202220850.png)图 18：创建合成帧的合成器线程。先将帧发送到浏览器进程，然后再发送到 GPU</p><p>合成的好处是，</p><p>在不涉及主线程的情况下完成。合成器线程不需要等待样式计算或 JavaScript 执行。因此，<a href="https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/" target="_blank" rel="noreferrer">仅合成动画</a>被认为是实现流畅性能的最佳选择。如果需要再次计算布局或绘制，则必须涉及主线程。</p>',45),n=[s];function p(i,c,l,d,h,m){return a(),t("div",null,n)}const b=e(o,[["render",p]]);export{u as __pageData,b as default};
