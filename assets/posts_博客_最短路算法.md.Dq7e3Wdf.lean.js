import{_ as h,c as t,j as s,a as i,a4 as a,o as n}from"./chunks/framework.Da5du0GI.js";const Qs=JSON.parse('{"title":"最短路算法","description":"","frontmatter":{"title":"最短路算法","mathjax":true,"tags":["最短路"],"categories":"图论","abbrlink":789,"date":"2022-10-04 18:15:09","lastUpdated":"2022-10-04 18:15:09"},"headers":[],"relativePath":"_posts/博客/最短路算法.md","filePath":"_posts/博客/最短路算法.md","lastUpdated":1718520894000}'),l={name:"_posts/博客/最短路算法.md"},e=a("",23),p={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},k={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"5.832ex",height:"2.452ex",role:"img",focusable:"false",viewBox:"0 -833.9 2577.6 1083.9","aria-hidden":"true"},d=a("",1),r=[d],T=s("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("msup",null,[s("mi",null,"n"),s("mn",null,"2")]),s("mo",{stretchy:"false"},")")])],-1),Q=a("",4),E={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},g={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.464ex"},xmlns:"http://www.w3.org/2000/svg",width:"4.208ex",height:"2.034ex",role:"img",focusable:"false",viewBox:"0 -694 1860 899","aria-hidden":"true"},o=a("",1),y=[o],m=s("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("mi",null,"l"),s("mi",null,"o"),s("mi",null,"g"),s("mi",null,"n")])],-1),c={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},F={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.464ex"},xmlns:"http://www.w3.org/2000/svg",width:"6.195ex",height:"2.034ex",role:"img",focusable:"false",viewBox:"0 -694 2738 899","aria-hidden":"true"},D=a("",1),A=[D],u=s("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("mi",null,"m"),s("mi",null,"l"),s("mi",null,"o"),s("mi",null,"g"),s("mi",null,"n")])],-1),_={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},f={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"15.564ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 6879.4 1000","aria-hidden":"true"},w=a("",1),H=[w],x=s("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",null,"+"),s("mi",null,"m"),s("mo",{stretchy:"false"},")"),s("mi",null,"l"),s("mi",null,"o"),s("mi",null,"g"),s("mi",null,"n"),s("mo",{stretchy:"false"},")")])],-1),C=a("",9),b={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},B={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"6.83ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 3019 1000","aria-hidden":"true"},V=a("",1),L=[V],M=s("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mi",null,"m"),s("mo",{stretchy:"false"},")")])],-1),v=a("",3),j={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},Z={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"6.83ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 3019 1000","aria-hidden":"true"},S=a("",1),P=[S],q=s("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mi",null,"m"),s("mo",{stretchy:"false"},")")])],-1),N=s("p",null,"BF的效率低在了哪里？显然是每次都遍历整个边集数组， 但其实其中真正的更新了dist的边却不多。",-1),I=s("p",null,[i('SPFA正是对BF算法这个痛点进行了优化。 "SPFA"， 即'),s("strong",null,"Shortest Path Faster Algorithm"),i("， 从名字上也能看出大家对其效率上的认可。")],-1),z=s("p",null,"SPFA基于这样一个事实： 对于边[src, dest, weight]， 只有当dist[src]发生改变后， 该边才可能用于更新dist[dest]， 这就是说**只有dist发生改变的顶点的出边才有被遍历的价值。**这一点与Dijkstra算法不谋而合， 所以SPFA与Dijkstra算法在形式上是类似的。",-1),R=s("p",null,"对于SPFA是实现细节， 特别要提的一点是st数组， 在这里st[i]用于标记顶点i是否在队列中， 以免顶点重复入队， 这显然是没用意义的。",-1),J={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},O={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"6.83ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 3019 1000","aria-hidden":"true"},G=a("",1),W=[G],$=s("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mi",null,"m"),s("mo",{stretchy:"false"},")")])],-1),U=a("",18),X=s("li",null,[s("p",null,[i("使用三维数组f[k][i][j]表示"),s("strong",null,"路径中(除源点和汇点)只出现过前k个顶点时"),i("， i顶点到j顶点的最短路径")])],-1),K=s("p",null,"当考虑f[k][i][j]时， 可分为两种情况： i->j最短路径不经过k顶点， 即f[k-1][i][j]; 经过k顶点， 即f[k - 1][i][k] + f[k - 1][k][j]。所以状态转移方程为：",-1),Y={tabindex:"0",class:"MathJax",jax:"SVG",display:"true",style:{direction:"ltr",display:"block","text-align":"center",margin:"1em 0",position:"relative"}},ss={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"56.647ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 25038 1000","aria-hidden":"true"},is=a("",1),as=[is],ts=s("mjx-assistive-mml",{unselectable:"on",display:"block",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",overflow:"hidden",width:"100%"}},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[s("mi",null,"f"),s("mo",{stretchy:"false"},"["),s("mi",null,"k"),s("mo",{stretchy:"false"},"]"),s("mo",{stretchy:"false"},"["),s("mi",null,"i"),s("mo",{stretchy:"false"},"]"),s("mo",{stretchy:"false"},"["),s("mi",null,"j"),s("mo",{stretchy:"false"},"]"),s("mo",null,"="),s("mi",null,"m"),s("mi",null,"i"),s("mi",null,"n"),s("mo",{stretchy:"false"},"("),s("mi",null,"f"),s("mo",{stretchy:"false"},"["),s("mi",null,"k"),s("mo",null,"−"),s("mn",null,"1"),s("mo",{stretchy:"false"},"]"),s("mo",{stretchy:"false"},"["),s("mi",null,"i"),s("mo",{stretchy:"false"},"]"),s("mo",{stretchy:"false"},"["),s("mi",null,"j"),s("mo",{stretchy:"false"},"]"),s("mo",null,","),s("mi",null,"f"),s("mo",{stretchy:"false"},"["),s("mi",null,"k"),s("mo",null,"−"),s("mn",null,"1"),s("mo",{stretchy:"false"},"]"),s("mo",{stretchy:"false"},"["),s("mi",null,"i"),s("mo",{stretchy:"false"},"]"),s("mo",{stretchy:"false"},"["),s("mi",null,"k"),s("mo",{stretchy:"false"},"]"),s("mo",null,"+"),s("mi",null,"f"),s("mo",{stretchy:"false"},"["),s("mi",null,"k"),s("mo",null,"−"),s("mn",null,"1"),s("mo",{stretchy:"false"},"]"),s("mo",{stretchy:"false"},"["),s("mi",null,"k"),s("mo",{stretchy:"false"},"]"),s("mo",{stretchy:"false"},"["),s("mi",null,"j"),s("mo",{stretchy:"false"},"]"),s("mo",{stretchy:"false"},")")])],-1),ns=a("",3);function hs(ls,es,ps,ks,ds,rs){return n(),t("div",null,[e,s("p",null,[i("每次选择至少都会确定一个顶点的最短路径， 所以至多要选择n次； 而每次选择的过程中都要遍历一次dist数组， 因此时间复杂度为"),s("mjx-container",p,[(n(),t("svg",k,r)),T])]),Q,s("p",null,[i("优先队列让取出dist最小的顶点能以O(1)的代价实现， 但每次取出后的调整为O("),s("mjx-container",E,[(n(),t("svg",g,y)),m]),i(")， 遍历所有边为O("),s("mjx-container",c,[(n(),t("svg",F,A)),u]),i(")， 因此时间复杂度为"),s("mjx-container",_,[(n(),t("svg",f,H)),x])]),C,s("p",null,[i("设边的数量为m， 则BF算法的时间复杂度为"),s("mjx-container",b,[(n(),t("svg",B,L)),M]),i("。")]),v,s("p",null,[i("BF算法的时间复杂度为"),s("mjx-container",j,[(n(),t("svg",Z,P)),q]),i("， 在一般的图中m都是远大于n, 如此看来BF虽然能处理负权边， 但效率却远低于dijkstra。")]),N,I,z,R,s("p",null,[i("SPFA的复杂度并不稳定， 对于一般数据， 它要比朴素BF快得多， 甚至能以同样的时间处理正权图；但对于针对型数据， 复杂度最坏能退化到和BF一样的"),s("mjx-container",J,[(n(),t("svg",O,W)),$]),i("。")]),U,s("ul",null,[X,s("li",null,[K,s("mjx-container",Y,[(n(),t("svg",ss,as)),ts])])]),ns])}const Es=h(l,[["render",hs]]);export{Qs as __pageData,Es as default};
