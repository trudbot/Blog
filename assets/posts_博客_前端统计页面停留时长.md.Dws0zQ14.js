import{_ as a,c as i,a3 as o,o as r}from"./chunks/framework.C2eWyT4L.js";const g=JSON.parse('{"title":"前端统计页面停留时长","description":"","frontmatter":{"title":"前端统计页面停留时长","lastUpdated":"2024-09-09 14:39:54","date":"2024-09-09 14:39:43"},"headers":[],"relativePath":"_posts/博客/前端统计页面停留时长.md","filePath":"_posts/博客/前端统计页面停留时长.md","lastUpdated":1725864037000}'),l={name:"_posts/博客/前端统计页面停留时长.md"};function t(n,e,s,p,d,h){return r(),i("div",null,e[0]||(e[0]=[o('<p>需求: 统计用户在某个页面的停留时间, (排除用户离开标签页的时间)</p><h3 id="浏览器标签页生命周期" tabindex="-1">浏览器标签页生命周期 <a class="header-anchor" href="#浏览器标签页生命周期" aria-label="Permalink to &quot;浏览器标签页生命周期&quot;">​</a></h3><p><img src="https://trudbot-md-img.oss-cn-shanghai.aliyuncs.com/202409091436124.png" alt="img"></p><h3 id="对web-app会话结束标志的定义" tabindex="-1">对web app会话结束标志的定义 <a class="header-anchor" href="#对web-app会话结束标志的定义" aria-label="Permalink to &quot;对web app会话结束标志的定义&quot;">​</a></h3><p>一次<strong>应用程序会话</strong>是指用户从进入应用程序到离开应用程序的整个交互过程。在这个过程中，用户可以进行各种操作，如浏览内容、提交表单、进行搜索等。通常来说会话开始于用户打开应用程序，并在用户关闭应用程序或长时间不活动时结束。</p><p>对于页面停留时间的统计上， 一般在会话开始时开启统计， 会话结束时结束并向服务端上传数据。</p><p></p><p>就目前的需求:</p><ol><li>页面加载时会话开始</li><li>页面卸载/失活 后会话结束</li><li>页面为hidden(暂时离开当前页面)的时间不计入结果</li></ol><p></p><h3 id="理想态" tabindex="-1"><strong>理想态</strong> <a class="header-anchor" href="#理想态" aria-label="Permalink to &quot;**理想态**&quot;">​</a></h3><p>我们可以把页面的死亡方式分为三类。</p><ul><li>浏览器杀活。</li></ul><p>当长时间离开一个页面时， 浏览器逐步释放标签页占用的资源， 此过程不触发页面卸载相关事件。</p><ol><li>forzen。 此阶段页面的大部分javascript暂停执行， 动画也会停止。</li><li>discarded。 页面的资源完全释放， 重新访问页面时， 页面会重新加载。</li></ol><p>由于forzen状态js停止， 所以<strong>进入forzen状态前</strong>是最后的可以上报数据的时间点。</p><ul><li>SPA页面跳转</li></ul><p>SPA的页面跳转虽然视觉上可能和打开新页面无异， 但实际上仍然是同一个页面, 并不会触发页面的卸载事件。</p><p>此种死亡方式使用前端框架的组件卸载钩子监听即可。</p><ul><li>页面卸载</li></ul><p>页面卸载有很多种触发方式， 如:</p><ol><li>关闭标签页</li><li>关闭浏览器</li><li>页内地址栏跳转、路由进退</li><li>等等</li></ol><p>页面卸载一般使用pagehide、<s>beforeunload</s>事件监听。</p><hr><p>在理想状态中，</p><ul><li>visible到hidden: 使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API" target="_blank" rel="noreferrer">Page Visibility Api</a></li><li>浏览器杀活导致死亡: 监听freeze事件</li><li>SPA页面跳转: 使用react卸载钩子</li><li>正常标签页卸载: 监听pagehide事件</li></ul><p>我们只需要记录页面在visible状态停留的时间， 并在页面死亡时将时间总和上报。</p><p><img src="https://trudbot-md-img.oss-cn-shanghai.aliyuncs.com/202409091437303.png" alt="img"></p><p></p><h4 id="问题一-页面生命周期api-freeze、resume-兼容性差" tabindex="-1"><strong>问题一： 页面生命周期API(freeze、resume)兼容性差</strong> <a class="header-anchor" href="#问题一-页面生命周期api-freeze、resume-兼容性差" aria-label="Permalink to &quot;**问题一： 页面生命周期API(freeze、resume)兼容性差**&quot;">​</a></h4><p>其中较为关键的是<strong>freeze event,</strong> 我们需要用它监听浏览器冻结标签页的行为。</p><p>否则当标签页生命结束于冻结时（用户长时间离开标签页）， 此前的数据无法被上报。</p><p><img src="https://trudbot-md-img.oss-cn-shanghai.aliyuncs.com/202409091435949.png" alt="img"></p><h4 id="问题二-标签页卸载api-pagehide-beforeunload-的触发不可靠-尤其是移动端" tabindex="-1"><strong>问题二: 标签页卸载api(pagehide, beforeunload)的触发不可靠（尤其是移动端）</strong> <a class="header-anchor" href="#问题二-标签页卸载api-pagehide-beforeunload-的触发不可靠-尤其是移动端" aria-label="Permalink to &quot;**问题二: 标签页卸载api(pagehide, beforeunload)的触发不可靠（尤其是移动端）**&quot;">​</a></h4><p>比如以下操作流程并不会触发pagehide、beforeunload事件:</p><ol><li>用户从浏览器切换到其他app</li><li>用户在任务管理器后台中杀死浏览器进程</li></ol><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon#sending_analytics_at_the_end_of_a_session" target="_blank" rel="noreferrer">https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon#sending_analytics_at_the_end_of_a_session</a></p><h3 id="方案一-忽略杀活和特殊情况-目前选择" tabindex="-1">方案一： 忽略杀活和特殊情况（目前选择） <a class="header-anchor" href="#方案一-忽略杀活和特殊情况-目前选择" aria-label="Permalink to &quot;方案一： 忽略杀活和特殊情况（目前选择）&quot;">​</a></h3><p><img src="https://trudbot-md-img.oss-cn-shanghai.aliyuncs.com/202409091437086.png" alt="img"></p><p>优点: 以页面卸载作为会话结束标志, 符合原需求</p><p>缺点: 存在特殊的场景case。</p><h3 id="方案二-使用hidden作为会话结束状态" tabindex="-1">方案二: 使用hidden作为会话结束状态 <a class="header-anchor" href="#方案二-使用hidden作为会话结束状态" aria-label="Permalink to &quot;方案二:  使用hidden作为会话结束状态&quot;">​</a></h3><p><img src="https://trudbot-md-img.oss-cn-shanghai.aliyuncs.com/202409091436315.png" alt="img"></p><p>优点:</p><ul><li>无论是terminated还是discarded都会经过hidden状态， 覆盖场景全面</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API" target="_blank" rel="noreferrer">Page Visibility Api</a> 兼容性好</li><li>逻辑简单</li></ul><p><img src="https://trudbot-md-img.oss-cn-shanghai.aliyuncs.com/202409091438768.png" alt="img"></p><p>缺点：用户切出a标签页-&gt;用户回到a标签页， 会算作两次会话， 不符合目前的产品需求。</p><p></p><h3 id="beacon-api" tabindex="-1">Beacon API <a class="header-anchor" href="#beacon-api" aria-label="Permalink to &quot;Beacon API&quot;">​</a></h3><p>浏览器页面的卸载是一个快速的过程。 对于浏览器卸载过程中的XMLHTTPRequest或者fetch请求， 浏览器不保证执行。</p><p></p><p><code>Beacon API</code> 是一种用于在页面卸载或隐藏时发送少量数据到服务器的 Web API。它的设计目的是提供一种可靠且高效的方法来发送数据，而不会阻塞页面的卸载过程。<code>Beacon API</code> 适用于发送分析数据、日志信息或其他需要在页面关闭时发送的数据。</p><h4 id="主要特点" tabindex="-1"><strong>主要特点</strong> <a class="header-anchor" href="#主要特点" aria-label="Permalink to &quot;**主要特点**&quot;">​</a></h4><ol><li><strong>异步发送</strong>：<code>Beacon API</code> 发送数据是异步的，不会阻塞页面的卸载过程。</li><li><strong>可靠性</strong>：即使在页面卸载或隐藏时，<code>Beacon API</code> 也能确保数据被成功发送。</li></ol><h4 id="使用方法" tabindex="-1">使用方法 <a class="header-anchor" href="#使用方法" aria-label="Permalink to &quot;使用方法&quot;">​</a></h4><p><code>navigator.sendBeacon()</code> 方法是 <code>Beacon API</code> 的核心，用于发送数据。它接受两个参数：目标 URL 和要发送的数据。</p><h4 id="语法" tabindex="-1">语法 <a class="header-anchor" href="#语法" aria-label="Permalink to &quot;语法&quot;">​</a></h4><div class="language-tsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">navigator.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sendBeacon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(url, data);</span></span></code></pre></div><ul><li><code>url</code>：字符串，表示数据发送的目标 URL。</li><li><code>data</code>：可选，表示要发送的数据，可以是 <code>ArrayBufferView</code>、<code>Blob</code>、<code>DOMString</code> 或 <code>FormData</code> 对象等等。</li></ul><h3 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h3><p><a href="https://developer.chrome.com/docs/web-platform/page-lifecycle-api#developer-recommendations-for-each-state" target="_blank" rel="noreferrer">Page Lifecycle API</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API" target="_blank" rel="noreferrer">Page Visibility API</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Beacon_API" target="_blank" rel="noreferrer">Beacon API</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/pagehide_event" target="_blank" rel="noreferrer">pagehide</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/beforeunload_event" target="_blank" rel="noreferrer">beforeunload</a></p>',65)]))}const b=a(l,[["render",t]]);export{g as __pageData,b as default};
